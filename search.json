[{"title":"Charles-mcp-server设计","url":"/post/9670f09e.html","content":"charles太封闭了，没给二次开发者预留一点操作的可能性，只有基于Web Interface Settings做一些简单的功能，逆向开发风险太高了，很有可能吃力不讨好。\nWeb Interface Settings网上没有现成api文档，那就只能自己爬了：\nimport requestsfrom bs4 import BeautifulSoupfrom urllib.parse import urljoinfrom requests.auth import HTTPBasicAuth  # --- 配置 ---AUTH = HTTPBasicAuth(&#x27;tower&#x27;, &#x27;123456&#x27;)PROXIES = &#123;&quot;http&quot;: &quot;http://127.0.0.1:8888&quot;&#125;BLACKLIST = [&#x27;enable&#x27;, &#x27;disable&#x27;, &#x27;start&#x27;, &#x27;stop&#x27;, &#x27;clear&#x27;, &#x27;quit&#x27;, &#x27;reset&#x27;, &#x27;export&#x27;]def simple_safe_crawl(url, visited=None):    if visited is None: visited = set()    if url in visited: return []    visited.add(url)    if any(word in url.lower() for word in BLACKLIST):        return [f&quot;&#123;url&#125;&quot;]    try:        # print(f&quot;正在扫描目录: &#123;url&#125;&quot;)        resp = requests.get(url, auth=AUTH, proxies=PROXIES, timeout=3)        soup = BeautifulSoup(resp.text, &#x27;html.parser&#x27;)        all_found = []        for a in soup.find_all(&#x27;a&#x27;):            href = a.get(&#x27;href&#x27;)            if not href or href.startswith(&#x27;..&#x27;): continue            full_url = urljoin(url, href)            all_found.extend(simple_safe_crawl(full_url, visited)        return all_found    except:        return []  if __name__ == &quot;__main__&quot;:    results = simple_safe_crawl(&quot;http://control.charles/&quot;)    print(&quot;\\n--- 最终扫描结果 ---&quot;)    for r in sorted(list(set(results))):        print(r)\n接口如下：\nhttp://control.charles/quithttp://control.charles/recording/starthttp://control.charles/recording/stophttp://control.charles/session/clearhttp://control.charles/session/export-csvhttp://control.charles/session/export-harhttp://control.charles/session/export-jsonhttp://control.charles/session/export-tracehttp://control.charles/session/export-xmlhttp://control.charles/tools/allow-list/disablehttp://control.charles/tools/allow-list/enablehttp://control.charles/tools/auto-save/disablehttp://control.charles/tools/auto-save/enablehttp://control.charles/tools/block-cookies/disablehttp://control.charles/tools/block-cookies/enablehttp://control.charles/tools/block-list/disablehttp://control.charles/tools/block-list/enablehttp://control.charles/tools/breakpoints/disablehttp://control.charles/tools/breakpoints/enablehttp://control.charles/tools/client-process/disablehttp://control.charles/tools/client-process/enablehttp://control.charles/tools/dns-spoofing/disablehttp://control.charles/tools/dns-spoofing/enablehttp://control.charles/tools/map-local/disablehttp://control.charles/tools/map-local/enablehttp://control.charles/tools/map-remote/disablehttp://control.charles/tools/map-remote/enablehttp://control.charles/tools/no-caching/disablehttp://control.charles/tools/no-caching/enablehttp://control.charles/tools/rewrite/disablehttp://control.charles/tools/rewrite/enable\n目前的需求是：\n\n环境初始化与目标锁定\n\n精准、快速地获取数据\n\n动态篡改返回结果\n\n弱网环境一键切换\n\n紧急复位,当调试结束，或者环境配置混乱时，让 AI 能够一键恢复 Charles 到纯净抓包状态。\n成品：tianhetonghua&#x2F;Charles-mcp-server\n\n\n","tags":["Tools"]},{"title":"Frida用法快查表","url":"/post/453c1aa4.html","content":"一、处理重载方法（Overloads Handling）场景：区分同名但参数类型不同的方法（如 int 和 String 输入的不同逻辑）关键点：使用 .overload() 指定参数类型，或通过 .overloads 遍历所有版本\nvar MyClass = Java.use(&#x27;com.example.MyClass&#x27;);// 指定参数类型为 int 和 String 的重载方法MyClass.myMethod.overload(&#x27;int&#x27;, &#x27;java.lang.String&#x27;).implementation = function(a, b) &#123;    console.log(`参数: $&#123;a&#125;, $&#123;b&#125;`);    return this.myMethod(a, b); // 调用原始方法&#125;;// 遍历所有重载版本MyClass.myMethod.overloads.forEach(overload =&gt; &#123;    overload.implementation = function(...args) &#123;        console.log(`重载方法调用，参数类型: $&#123;args.map(arg =&gt; arg.type)&#125;`);        return this.myMethod(...args);    &#125;;&#125;);\n二、构造函数 Hook（Constructor Hooking）场景：篡改对象初始化参数（如绕过校验逻辑）限制：避免直接 Hook Android 组件生命周期（如 Activity 实例化）\nvar Checker = Java.use(&#x27;com.example.Checker&#x27;);Checker.$init.overload(&#x27;int&#x27;, &#x27;int&#x27;).implementation = function(a, b) &#123;    console.log(`原始构造参数: $&#123;a&#125;, $&#123;b&#125;`);    // 强制修改构造参数    this.$init(1234, 4321); // 调用修改后的构造函数&#125;;\n\n三、动态实例操作（Dynamic Instance Manipulation）场景：调用未主动触发的隐藏方法，或获取内存中对象数据（如解密密钥）优势：直接操作运行时对象，无需依赖代码逻辑触发\nJava.choose(&#x27;com.example.MainActivity&#x27;, &#123;    onMatch: function(instance) &#123;        console.log(`找到实例: $&#123;instance&#125;`);        instance.secretMethod(); // 调用隐藏方法        // 获取实例字段值        console.log(`私有字段值: $&#123;instance.privateField.value&#125;`);    &#125;,    onComplete: () =&gt; console.log(&#x27;实例遍历完成&#x27;)&#125;);\n\n四、Native 层 Hook（Native Function Interception）场景：监控 C&#x2F;C++ 原生函数（如文件操作、网络通信）扩展：结合 Stalker 追踪代码执行路径\nconst openPtr = Module.findExportByName(&#x27;libc.so&#x27;, &#x27;open&#x27;); // 定位原生函数地址Interceptor.attach(openPtr, &#123;    onEnter: function(args) &#123;        // 读取 C 字符串参数        const filename = Memory.readUtf8String(args[0]);        console.log(`打开文件: $&#123;filename&#125;`);        // 修改参数（示例：拦截并返回特定文件描述符）        // args[0] = Memory.allocUtf8String(&#x27;/dev/null&#x27;);    &#125;,    onLeave: function(retval) &#123; // retval 为原生函数返回值        console.log(`返回值（文件描述符）: $&#123;retval.toInt32()&#125;`);    &#125;&#125;);\n\n五、静态方法与全局变量操作（Static Methods &amp; Variables）注意：静态方法需正确匹配参数类型，避免因重载导致 Hook 失效\nvar MainActivity = Java.use(&#x27;com.example.MainActivity&#x27;);// 修改静态变量（如全局配置项）MainActivity.staticVar.value = 512; // 直接赋值// 钩取静态方法MainActivity.staticMethod.implementation = function() &#123;    console.log(&#x27;静态方法被 Hook&#x27;);    return &quot;Hijacked!&quot;; // 替换返回值&#125;;\n\n六、批量 Hook 所有重载方法（Bulk Overload Hooking）场景：快速覆盖混淆代码中的所有方法重载版本\nfunction hookAllOverloads(className, methodName) &#123;    const clazz = Java.use(className);    clazz[methodName].overloads.forEach(overload =&gt; &#123;        overload.implementation = function(...args) &#123;            console.log(`[$&#123;methodName&#125;] 调用参数: $&#123;args&#125;`);            // 可选：修改参数（如固定第一个参数为 0）            // args[0] = 0;            return this[methodName](...args); // 调用原始方法        &#125;;    &#125;);&#125;// 使用示例：批量 Hook 所有重载的 `parse` 方法hookAllOverloads(&#x27;com.example.Parser&#x27;, &#x27;parse&#x27;);\n\n七、参数与返回值篡改（Argument &amp; Return Value Manipulation）技巧：结合 Frida Python 端 send() 实现动态策略调整\nMyClass.check.implementation = function(a, b) &#123;    // 修改输入参数（固定第二个参数为 100）    const result = this.check(a, 100);     // 反转校验结果（示例：通过校验时返回失败）    return result === 0 ? 1 : 0; &#125;;\n\n八、工具链扩展（Toolchain Integration）1. Frida-trace 快速追踪命令：追踪所有以 open 开头的原生函数，以及 Java 层 Socket 相关方法\nfrida-trace -U -i &quot;open*&quot; -j &#x27;*java.net.Socket*&#x27; com.example.app\n\n2. 内存操作（Memory API）场景：直接读写进程内存，绕过加密逻辑\n// 读取指定地址的 4 字节整数const value = Memory.readInt(ptr(&#x27;0x7aabbcc0&#x27;)); // 写入字符串到内存（自动计算长度）Memory.writeUtf8String(ptr(&#x27;0x7aabbcc0&#x27;), &#x27;hacked&#x27;);\n\n附：常用命令行参数\n\n\n参数\n说明\n\n\n\n-U\n通过 USB 连接设备（默认优先选择 USB 设备）\n\n\n-f &lt;包名&gt;\n启动指定应用并注入脚本（自动 attach）\n\n\n-l &lt;脚本.js&gt;\n加载指定 JavaScript 脚本\n\n\n-D &lt;设备ID&gt;\n连接指定 ID 的设备（多设备场景）\n\n\n","tags":["安卓逆向"]},{"title":"Unidbg补环境基础","url":"/post/90e7f31c.html","content":"补环境需要详细的调试信息，建议开启详细日志：vm.setVerbose(true)\n系统库函数依赖扩展点：SyscallHandler.javaeg:\n//替换默认处理器AndroidEmulatorBuilder builder = new AndroidEmulatorBuilder(true) &#123;      @Override      public AndroidEmulator build() &#123;          return new AndroidARM64Emulator(processName, rootDir, backendFactories) &#123;              @Override              protected UnixSyscallHandler&lt;AndroidFileIO&gt; createSyscallHandler(SvcMemory svcMemory) &#123;                  return new MySyscallHandler(svcMemory);//MySyscallHandler为自定义类            &#125;          &#125;;      &#125;  &#125;;  builder.setProcessName(&quot;进程名&quot;);  emulator = builder.build();....public class MySyscallHandler extends ARM64SyscallHandler &#123;      public MySyscallHandler(SvcMemory svcMemory) &#123;          super(svcMemory);          setVerbose(true); // 可按需开启详细日志      &#125;      // 在这里重写或添加你的处理逻辑          ......    &#125;  \n补JNI，Java层的调用继承：AbstractJni.javaeg:\n...//创建DalvikVM实例之后vm.setjni(this)...//后面继承与重写建议在同路径下新建JAVA文件再写//xxxx可以是`Object`, `Boolean`, `Int`, `Void` 等，根据报错判断public class MyJNI extends AbstractJni&#123;\t@Override//模拟静态方法\tpublic DvmObject&lt;?&gt; callStaticxxxxxxMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;              switch (signature) &#123;                  case &quot;com/example/MyClass-&gt;getAppContext()Landroid/content/Context;&quot;:                      // 返回一个模拟的 Context 对象                      return vm.resolveClass(&quot;android/content/Context&quot;).newObject(null);                  // 可以添加更多 case 来处理其他需要补全的 Java 方法                  default:                      // 对于未处理的方法，务必调用父类的默认实现                      return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);              &#125;          &#125;        @Override  //模拟构造方法\tpublic DvmObject&lt;?&gt; newObejectV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;  \t    switch (signature) &#123;  \t        case &quot;java/util/HashMap-&gt;&lt;init&gt;()V&quot;: &#123;  \t            return ProxyDvmObject.createObject(vm, new HashMap&lt;&gt;());  \t        &#125;    \t        case &quot;com/zj/wuaipojie/ui/ChallengeTen$UserInfo-&gt;&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;JLjava/lang/String;Lcom/zj/wuaipojie/ui/ChallengeTen$AccountStatus;Ljava/util/Map;)V&quot;: &#123;  \t            System.out.println(&quot;【补环境 Level 3】拦截到 UserInfo 构造方法&quot;);  \t            Map&lt;String, DvmObject&lt;?&gt;&gt; userInfoData = new HashMap&lt;&gt;();  \t            userInfoData.put(&quot;status&quot;, vaList.getObjectArg(4));  \t            userInfoData.put(&quot;properties&quot;, vaList.getObjectArg(5));  \t            return dvmClass.newObject(userInfoData);  \t        &#125;  \t    &#125;  \t    return super.newObjectV(vm, dvmClass, signature, vaList);  \t&#125;\t@Override  //模拟字段访问\tpublic DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123;  \t    // 匹配枚举类的 PREMIUM 静态字段  \t    if (&quot;com/zj/wuaipojie/ui/ChallengeTen$AccountStatus-&gt;PREMIUM:Lcom/zj/wuaipojie/ui/ChallengeTen$AccountStatus;&quot;.equals(signature)) &#123;  \t        System.out.println(&quot;【补环境】拦截到获取 AccountStatus.PREMIUM 静态字段&quot;);  \t        // 创建一个枚举实例（用字符串&quot;PREMIUM&quot;作为其值，方便后续name()方法返回正确结果）  \t        DvmObject&lt;?&gt; premium = dvmClass.newObject(&quot;PREMIUM&quot;);  \t        return premium;  \t    &#125;  \t    return super.getStaticObjectField(vm, dvmClass, signature);  \t&#125;    \t@Override  \tpublic void setIntField(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, int value) &#123;  \t    // signature的格式是：com/example/User-&gt;age:I  \t    if (&quot;com/example/User-&gt;age:I&quot;.equals(signature)) &#123;  \t        System.out.println(&quot;SO 正在设置 User 对象的 age 字段，值为: &quot; + value);  \t        // 你可以在这里记录值，或者什么都不做  \t        return; // 注意set方法是void返回  \t    &#125;  \t    super.setIntField(vm, dvmObject, signature, value);  \t&#125;&#125;\n补文件访问unidbg有责任机制：优先是用户定义的文件处理器-&gt;unidbg默认文件处理器添加文件处理器（在模拟执行之前）:emulator.getSyscallHandler().addIOResolver()1、继承：IOResolver.java\nemulator.getSyscallHandler().addIOResolver(this);//注册IOResolver......public FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String pathname, int oflags) &#123;\tSystem.out.println(&quot;[IOResolver] Intercepted file access -&gt; Path: &#x27;&quot; + pathname + &quot;&#x27;, Flags: &quot; + oflags);\tswitch(pathname)&#123;\t\tcase &quot;xxxx&quot;:\t\t\treturn FileResult.success(new ByteArrayFileIO(oflags, pathname, 字符串.getBytes()))//动态文件，只能读\t\tcase &quot;xxxxxx&quot;:\t\t\treturn  FileResult.success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/cpu/boot_id&quot;), pathname));//物理文件，可读写\t\tcase &quot;xxxxx&quot;:\t\t\treturn FileResult.failed(UnixEmulator.EACCES)；//访问失败\t&#125;&#125;\n2、rootDir：\nemulator = AndroidEmulatorBuilder                .for64Bit()                //虚拟目录                .setRootDir(new File(&quot;unidbg-android/src/test/resources/FileDemo/VFS&quot;))                .build();//创建仿真器的时候创建根目录//直接操作VFS文件夹，so产生的所有文件访问最后兜底的就是这个文件系统，\n优先级：IOResolver  &gt; rootDir，均属于VFS系统。可以同时使用。\n如何看报错判断缺失数据类型：signature的组成一般是：(类路径)-&gt;(字段名):(字段类型签名);例如com/zj/wuaipojie/util/SecurityUtil$Config-&gt;deviceId:Ljava/lang/String;:com/zj/wuaipojie/util/SecurityUtil$Config:表示在config这个子类中；deviceId:表示缺的是config类中的deviceId成员变量；Ljava/lang/String;:表示这个变量的类型是一个字符串。由此可知我们在补环境时，补的是一个字符串变量。\n一个较完整补环境模板MainActivity.java:\npackage com.example;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.file.FileResult;import com.github.unidbg.file.IOResolver;import com.github.unidbg.file.linux.AndroidFileIO;import com.github.unidbg.linux.android.AndroidARM64Emulator;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.file.ByteArrayFileIO;import com.github.unidbg.linux.file.SimpleFileIO;import com.github.unidbg.memory.Memory;import com.github.unidbg.memory.SvcMemory;import com.github.unidbg.unix.UnixEmulator;import com.github.unidbg.unix.UnixSyscallHandler;import com.example.MySyscallHandler;import net.dongliu.apk.parser.Main;import java.io.File;import java.io.FileNotFoundException;public class MainActivity extends AbstractJni implements IOResolver&lt;AndroidFileIO&gt; &#123;    private final  AndroidEmulator emulator ;    private final  VM vm;    private final Module module;    public MainActivity()&#123;        //替换默认处理器        AndroidEmulatorBuilder builder = new AndroidEmulatorBuilder(true) &#123;            @Override            public AndroidEmulator build() &#123;                return new AndroidARM64Emulator(processName, rootDir, backendFactories) &#123;                    @Override                    protected UnixSyscallHandler&lt;AndroidFileIO&gt; createSyscallHandler(SvcMemory svcMemory) &#123;                        return new MySyscallHandler(svcMemory);                    &#125;                &#125;;            &#125;        &#125;;        builder.setProcessName(&quot;进程名&quot;);        emulator = builder.setRootDir(new File(&quot;unidbg/unidbg-android/src/test/resources/example&quot;)).build();//创建模拟器,设置模拟文件系统（补文件访问环境）        emulator.getSyscallHandler().setVerbose(true);//开启详细日志        emulator.getSyscallHandler().addIOResolver(this);//注册IOResolver        final Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM();        MyJni myjni=new MyJni(vm);        vm.setJni(myjni);        vm.setVerbose(true);        File soFile = new File(&quot;unidbg-android/src/test/so路径&quot;);        DalvikModule dm = vm.loadLibrary(soFile, true);        module = dm.getModule();        dm.callJNI_OnLoad(emulator);    &#125;    //补文件访问    @Override    public FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String pathname, int oflags) &#123;        // 无论是否处理，都打印出来，这是发现未知文件访问的关键。        System.out.println(&quot;[IOResolver] Intercepted file access -&gt; Path: &#x27;&quot; + pathname + &quot;&#x27;, Flags: &quot; + oflags);        switch(pathname)&#123;            case &quot;xxxxxxx&quot;:&#123;                String statusContent=&quot;xxxxxxxxxxxx&quot;;                return FileResult.success(new ByteArrayFileIO(oflags, pathname, statusContent.getBytes()));//成功返回，动态，仅可读，不可写            &#125;            case &quot;xxxxxx&quot;: &#123;                //.......                return FileResult.success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/cpu/boot_id&quot;), pathname));//物理文件，可读写            &#125;            case &quot;xxxxx&quot;: &#123;                //........                return FileResult.failed(UnixEmulator.EACCES);//访问失败,权限不足            &#125;        &#125;        return null;//return null表示交给下一个处理器    &#125;    public void run()&#123;        DvmClass securityUtilClass = vm.resolveClass(&quot;&quot;);        StringObject result = securityUtilClass.callStaticJniMethodObject(emulator, &quot;&quot;);    &#125;    public static void main(String[] args) throws FileNotFoundException &#123;        MainActivity myinstance=new MainActivity();        myinstance.run();    &#125;&#125;\n\nMyJni.java:\npackage com.example;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.VM;public class MyJni extends AbstractJni &#123;    private final VM vm;    public MyJni(VM vm) &#123;        this.vm=vm;        super();    &#125;//    补JNI环境//    @Override//    public .......&#125;\n\nMySyscallHandler:\npackage com.example;import com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.Backend;import com.github.unidbg.linux.ARM64SyscallHandler;import com.github.unidbg.memory.SvcMemory;import java.util.Random;public class MySyscallHandler extends ARM64SyscallHandler&#123;    private final Random rng = new Random();    public MySyscallHandler(SvcMemory svcMemory) &#123;        super(svcMemory);        setVerbose(true); // 可按需开启详细日志    &#125;    @Override    protected boolean handleUnknownSyscall(Emulator&lt;?&gt; emulator, int NR) &#123;        System.err.println(&quot;&gt;&gt;&gt; MySyscallHandler is processing syscall NR = &quot; + NR);        Backend backend = emulator.getBackend();        switch (NR) &#123;            case 1: &#123;                //To Do            &#125;            case 2: &#123;                //To do            &#125;        &#125;        return super.handleUnknownSyscall(emulator, NR);    &#125;&#125;\n\n\n\n\n\n\n\n学习资源：《安卓逆向这档事》\n","tags":["安卓逆向"]},{"title":"FlowDAM：让Charles仅代理指定app的流量","url":"/post/5a5a11af.html","content":"Charles本身是很好的手机app流量代理工具，对代理的流量有很好的分类和梳理，但是对比同类型的代理工具，charles始终有一个痛点，它仅能被动接收手机端流量，最后展示出来的就是一片混乱。\n我通过iptables对手机中指定app的流量过滤，交由sing-box进行转发，实现了对指定app流量的专有代理，并且没有数量限制。因为使用到iptables，所以需要系统有root权限。\n如何使用要想让app能被charles代理，都得把charles的证书推入系统证书目录里去，基于root权限，有很多模块可以实现，例如MoveCertificate。\n\ncharles端得开启SOCKS proxy,端口自定义。\n\n打开DAM,填入电脑IP和刚才设置的端口：\n\n然后进入选择app列表，这里区分了系统应用和用户应用，可以通过按钮反选，还可以显示应用的uid。选中的app始终置顶 \n\n\n\n默认\n显示uid\n切换系统应用\n\n\n\n\n\n\n\n\n选好后，退回主页面，点击开始，就能实现代理了。\n\n如果按照上面的操作，但是Charles还是没有流量，多半是被电脑防火墙拦住了，可以创建相应的出入站规则来解决。\n项目网址：FlowDAM\n","tags":["Tools"]},{"title":"ctf-一人成军","url":"/post/458e03ef.html","content":"一人成军：这道题的前置条件有点多，一个root过的真机或者模拟器，要懂frida脚本怎么写等等。\n还有此题有一个严重的漏洞，关键加密函数被导出(写入了导出表)，使得可以脱机进行请求伪造，比赛唯二解都是这么做的，属于非预期了，但却不是最简单的解法。\n预期解：\n使用命令行frida -f com.tower.redrock -l test.js 或者frida -n com.tower.redrock -l test.js,这是两种模式，前一种是spawn模式，可以在程序没有启动的时候启动并注入，或者重新启动并注入已经运行的程序，后者attach模式，是注入正在运行的程序，得手动开启app。有兴趣的可以自己了解一下两者的原理。\n成功注入脚本后，输入用户名，然后点击一次注册（返回注册成功），接着点击助力（返回助力成功，如果返回”不能给自己助力”，就是脚本没注入成功），一共连续点击六次助力（因为脚本里写了六个助力者，都应该返回“助力成功”），最后再点击一次注册，这个时候就能拿到flag了。\n至于脚本为什么这么写，原因如下：\n逆向分析这部分不细致讲，反正唯一的一个网络请求是Java层调native层函数，用的静态注册，很好找。\n\n进去找到分析json是怎么拼的，&#123;\\&quot;a\\&quot;:\\&quot;%d\\&quot;,\\&quot;username\\&quot;:\\&quot;%s\\&quot;,\\&quot;fstatus\\&quot;:%d,\\&quot;fingerprint\\&quot;:\\&quot;%s\\&quot;,\\&quot;mac\\&quot;:\\&quot;%s\\&quot;,\\&quot;bt_mac\\&quot;:\\&quot;%s\\&quot;,\\&quot;serial\\&quot;:\\&quot;%s\\&quot;,\\&quot;baseband\\&quot;:\\&quot;%s\\&quot;，这些字段除了a,username不需要去试，其他每一个设备信息字段都应该去试一试替换，当username一致，但是我们替换掉某个字段信息时，点击助力能返回“助力成功”，就代表这个字段就是要找的设备唯一认证字段，可以给个脚本（没试过能不能跑通，可以自己改改）：\n//就以fingerprint为例function hook_getprop()&#123;    const addr=Module.findBaseAddress(&quot;libc.so&quot;).add(偏移);//偏移根据使用架构所在so中偏移确定，代码段的getprop函数的偏移，注意不是plt段的getprop函数的偏移    Interceptor.attach(addr,&#123;        onEnter:function(args)&#123;            this.flag=false;            this.args1=args[1];            if(Memory.readCString(args[0])==&quot;ro.serialno&quot;)&#123;                this.flag=true;            &#125;        &#125;,           onLeave:function(retval)&#123;            if(this.flag)&#123;                let value=fingerprint[count.next().value]                console.log(`当前fingerprint:$&#123;value&#125;`);                Memory.writeUtf8String(this.args1, value);            &#125;         &#125;    &#125;);&#125;hook_getprop();\n\n试过之后应该能发现是fingerprint这个字段，然后我们就hook替换就行，脚本里写了一个生成器，每次触发hook就会替换成不一样的值，这样就不用每个助力者都单独hook了。\nconst fingerprint=[&quot;注册用软指纹&quot;,&quot;第一个助力者&quot;,&quot;第二个助力者&quot;,&quot;第三个助力者&quot;,&quot;第四个助力者&quot;,&quot;第五个助力者&quot;,&quot;第六个助力者(下一步点击注册)&quot;,&quot;注册用软指纹&quot;];//内容任意、首尾一致就行function* idGen() &#123;  let id = 0;  while (true) yield id++;&#125;const count=idGen()function hook_getprop()&#123;    const addr=Module.findBaseAddress(&quot;libc.so&quot;).add(偏移);//偏移根据使用架构所在so中偏移确定    Interceptor.attach(addr,&#123;        onEnter:function(args)&#123;            t··his.flag=false;            this.args1=args[1];            if(Memory.readCString(args[0])==&quot;ro.build.fingerprint&quot;)&#123;                this.flag=true;            &#125;        &#125;,           onLeave:function(retval)&#123;            if(this.flag)&#123;                let value=fingerprint[count.next().value]                console.log(`当前fingerprint:$&#123;value&#125;`);                Memory.writeUtf8String(this.args1, value);            &#125;         &#125;    &#125;);&#125;hook_getprop();\n\n为什么hook   libc.so？因为libredrocksdk.so在编译的时候编译器选择直接调用系统库的导出函数，没有封装，那就只有直接hook函数定义的地方，就是libc.so\n如何查看偏移?可以把libc.so导出到电脑上，用ida查看。也可以直接用frida的Module.enumerateExports(&quot;libc.so&quot;),查看_system_property_get的内存地址，然后Module.findBaseAddress(&quot;libc.so&quot;)查看libc.so的内存地址，两者做差就是偏移。\n赛事服务端已经销毁了，现在可以自己搭建复现，服务端和配套客户端在下面这个压缩包。\nreproduction.zip\n","tags":["CTF"]},{"title":"mmmhua的模拟登录和部分通信协议分析","url":"/post/ceb595b0.html","content":"本文不构成任何技术操作指导或建议，仅供技术交流与学习参考。如发现本文内容存在可能违反法律规定的情况，请立即联系本人删除相关内容。（已对图片中出现的包名和应用名进行处理）\n本来想着实现一下这个漫画app的模拟登录，结果抓个包一看：data字段被加密，我先猜的Base64，但实际上没那么简单。进入jadx看看LoginActivity:\n手机验证登录部分：\ncase R.id.login_button /* 2131232486 */:     if (!this.cbServiceSelect.isChecked()) &#123;         ToastUtils.show(&quot;请勾选并同意《隐私政策》和《服务协议》&quot;);        return;    &#125; else if (l(this.loginPhoneEdit.getText().toString().trim())) &#123; // 获取输入的电话        if (this.loginCodeEdit.getText().toString().trim().length() != 0) &#123; // 验证码不为空            showDialog();            ApiParams apiParams = new ApiParams();            apiParams.with(Constants.RequestAction.getUser()); // return &quot;user/login&quot;;            apiParams.with(&quot;mobile&quot;, this.loginPhoneEdit.getText().toString().trim()); // 追加电话号码            apiParams.with(PluginConstants.KEY_ERROR_CODE, this.loginCodeEdit.getText().toString().trim()); // 追加验证码            ServiceProvider.postAsyn(this, this.q, apiParams, UserBean.class, this);            return;        &#125;        showToast(getResources().getString(R.string._please_input_validate_code));        return;    &#125; else &#123;        return;    &#125;\npostAysn-&gt;post-&gt;.....-&gt;DataRequestWrapper-&gt;p-&gt;n-&gt;b-&gt;converTobase64()-&gt;Base64.encode()这不仅是登录的调用栈，这个app的所有网络请求都是经过postAysn-&gt;p的过程。p是一个调度函数，根据功能的不同，实现不同的请求。\n继续分析这个登录请求，在方法b中，有个方法j，拼成最终的data，然后经由方法b进行加密。\n我在多次抓取请求的过程中，发现token的一些使用规则：\n\n存储在运行时文件token_sp.xml中\n由服务端生成，每次登陆时服务端会发送本次登录的会话token\n如果是在本设备上首次登录，可以使用默认token：”manmanDefaultToken”\n如果之前在本设备上退出登录，退出登录时服务端也会发送一个token，供下次登录使用\n\n由于抓包得到的内容不可读，需要hook一些方法和函数来验证：这是脚本：\nJava.perform(function () &#123;    let DataRequestWrapper = Java.use(&quot;com.itcode.reader.datarequest.neworkWrapper.DataRequestWrapper&quot;);    DataRequestWrapper.p.implementation = function (builder) &#123;        console.log(&quot;==== DataRequestWrapper.p() 被调用 ====&quot;);        // console.log(&quot;builder param map: &quot; + builder.f);        // console.log(&quot;builder type: &quot; + builder.h);        // console.log(&quot;builder tag: &quot; + builder.k);        let result = this.p.call(this, builder);        // console.log(&quot;p() 返回的 Request: &quot; + result);        // console.log(&quot;Request URL: &quot; + result.url());        // console.log(&quot;Request Headers: &quot; + result.headers());          let body=result.body();        if (body != null) &#123;            let Buffer = Java.use(&quot;okio.Buffer&quot;);            let buffer = Buffer.$new();            body.writeTo(buffer);            console.log(&quot;Request Body: &quot; + buffer.readUtf8());        &#125;        return result;    &#125;;    // DataRequestWrapper.n.implementation = function (str, bArr, obj) &#123;    //     console.log(`DataRequestWrapper.n is called:  bArr=$&#123;bArr&#125;,\\n, obj=$&#123;obj&#125;`);    //     let result = this[&quot;n&quot;](str, bArr, obj);    //     console.log(`DataRequestWrapper.n result=$&#123;result&#125;`);    //     return result;    // &#125;;     let JSONTools = Java.use(&quot;com.itcode.reader.datarequest.tool.JSONTools&quot;);    JSONTools[&quot;parseMapToJson&quot;].implementation = function (map) &#123;    let result = this[&quot;parseMapToJson&quot;](map);    console.log(`JSONTools.parseMapToJson result=$&#123;result&#125;`);    return result;    &#125;    DataRequestWrapper[&quot;convertToBase64&quot;].implementation = function (iArr) &#123;    console.log(`DataRequestWrapper.convertToBase64 is called: iArr=$&#123;iArr&#125;`);    let result = this[&quot;convertToBase64&quot;](iArr);    console.log(` 结果字符串原始=$&#123;result&#125;`);    const resultJs = Array.from(result); // 确保结果是JS数组    const resultStr = resultJs.map(code =&gt; String.fromCharCode(code)).join(&#x27;&#x27;);    console.log(` 结果字符串处理后=$&#123;resultStr&#125;`);    return result;&#125;;&#125;);\n\nJava.perform(function() &#123;    //验证函数n就是通信协议的最后一个函数    let DataRequestWrapper = Java.use(&quot;com.itcode.reader.datarequest.neworkWrapper.DataRequestWrapper&quot;);    DataRequestWrapper[&quot;n&quot;].implementation = function (str, bArr, obj) &#123;    console.log(`DataRequestWrapper.n is called: str=$&#123;str&#125;, bArr=$&#123;bArr&#125;, obj=$&#123;obj&#125;`);    let result = this[&quot;n&quot;](str, bArr, obj);    console.log(`DataRequestWrapper.n result=$&#123;result&#125;`);    return result;&#125;;    //查看验证函数j的逻辑，每次登陆产生的token不一样，首次使用app可用默认token：“manmanDefaultToken”    let JSONTools = Java.use(&quot;com.itcode.reader.datarequest.tool.JSONTools&quot;);    JSONTools[&quot;parseMapToJson&quot;].implementation = function (map) &#123;    let result = this[&quot;parseMapToJson&quot;](map);    console.log(`JSONTools.parseMapToJson result=$&#123;result&#125;`);    return result;&#125;;&#125;)\n最后，实现模拟登录：\nimport json  import time  import base64  import  requests    class Login():      def __init__(self,encode_pattern,mobile):          self.url=&quot;https://xxxxxxxxxxxxxxxxxx&quot;          self.headers = &#123;              &#x27;Content-Type&#x27;: &#x27;raw&#x27;,              &#x27;Accept-Encoding&#x27;: &#x27;gzip&#x27;,              &#x27;User-Agent&#x27;: &#x27;okhttp/3.14.9&#x27;,              &#x27;Host&#x27;: &#x27;api.tmanga.com&#x27;          &#125;          self.token=&#x27;&#x27;          self.encode_pattern=encode_pattern          self.mobile=mobile        def get_appversion_info(self):          return &quot;5.2.51^ONEPLUS A6010^android^android^9^oppo^373899aa3f886e93^98:09:CF:0C:D3:6D^869386043396293^202411010^^^^&quot;        def get_token(self):          #每次登录都有一个属于本次登陆的一个token，如果之前在本设备上退出了，设备会保留退出时服务器发送的token，如果没有这个token，获取验证码时的请求就会使用默认token            return &quot;manmanDefaultToken&quot;        def get_precom(self):          return 1        def fluter_and_add(self,param):          param.pop(&quot;wkParams&quot;,None)          #由于对于同一个设备的同一个用户而言，info恒定，这里就用抓到的信息，后续需要可以补充get_appversion_inf()          param[&quot;p_recom&quot;]=self.get_precom()          param[&quot;info&quot;]=self.get_appversion_info()          param[&quot;token&quot;]=self.get_token()          return json.dumps(param,ensure_ascii=False)        def log_encode(self,map,default):          log_json=self.fluter_and_add(map)          print(log_json)          if default==True:              times=int(time.time())              if times&lt;1000000000:                  times=1000000000              sb=str(log_json)+&#x27;3&#x27;+str(times)          else:              times=int(time.time())+1              if times&lt;1000000000:                  times=1000000000              sb=str(log_json)+str(times)            bytes_data = sb.encode(&#x27;utf-8&#x27;)          length = len(bytes_data)            c_arr = []          for byte in bytes_data:              c_arr.append(chr(byte &amp; 255))            i_arr = [0] * length          i3 = 0          i4 = 1            for i5 in range(length):              i6 = i5 % 5              if i6 == 0:                  if i3 % 2 == 0:                      i4 = 1                  else:                      i4 = -1                  i3 += 1                c = c_arr[i5]              if ord(c) &gt;= 127:                  i_arr[i5] = ord(c) - ord(&#x27;&#125;&#x27;)              else:                  i_arr[i5] = ord(c) + ord(&#x27;n&#x27;) + ((i6 + 1) * i4)            #coverTobase64函数部分          b_arr = bytearray((x &amp; 0xFF) for x in i_arr)          encoded_bytes = base64.b64encode(b_arr)            return encoded_bytes        def phone_login(self):          params=&#123;              &quot;mobile&quot;:self.mobile,              &quot;code&quot;:&#x27;&#x27;,              &quot;api&quot;:&quot;user/login&quot;          &#125;          params_code=&#123;              &quot;mobile&quot;:self.mobile,              &quot;api&quot;:&quot;verify-code/send&quot;          &#125;            code_data=self.log_encode(params_code,self.encode_pattern)          print(code_data)          response0 = requests.post(self.url, data=code_data, headers=self.headers)          print(response0.text)              params[&quot;code&quot;]=input(&quot;输入验证码： \\n&quot;)          log_data=self.log_encode(params,self.encode_pattern)          print(log_data)          response = requests.post(self.url, data=log_data, headers=self.headers)          print(response.text)          self.token=response.json().get(&quot;data&quot;).get(&quot;token&quot;)          print(self.token)    if __name__==&quot;__main__&quot;:        phone_login=Login(mobile=xxxxxxxxxxx,encode_pattern=True)      phone_login.phone_login()\n\n成功实现登录：\n","tags":["安卓逆向"]},{"title":"mmmhua支付链分析","url":"/post/41f7b84a.html","content":"掌握这个APP的支付逻辑其实蛮简单，主要关注调起支付软件之前的创建订单请求。\n1、先尝试发送支付时发送的一个请求，从抓的包来看，可能是更新支付状态，获取blottersCode和后续更新账号余额的api。先尝试使用登录时的加密算法发送这个请求，但是返回error验证究竟是不是使用的算法b：使用frida hook函数，发现发送这个请求的过程中是有调用b的，初步推断可能就是使用的b算法，经过我实现的log_decode算法，把这个请求的data解密后确能得到真实的data，就能肯定使用的是b算法，那么返回error就要排查其他原因。最后发现是因为没有使用j函数，导致传入log_encode的是str而不是json，这下把strTojson改到log_encode实现实现了伪造订单请求\ndef log_decode(self,encoded_bytes):      # base64 解码，得到 i_arr 原始字节      b_arr = base64.b64decode(encoded_bytes)      length = len(b_arr)      i_arr = list(b_arr)        c_arr = [&#x27;&#x27;] * length      i3 = 0      i4 = 1        for i5 in range(length):          i6 = i5 % 5          if i6 == 0:              if i3 % 2 == 0:                  i4 = 1              else:                  i4 = -1              i3 += 1            val = i_arr[i5]          ord_c = val - ord(&#x27;n&#x27;) - ((i6 + 1) * i4)          c_arr[i5] = chr(ord_c)      bytes_data = bytearray(ord(c) for c in c_arr)      return bytes_data\n返回的data字段里包含众多账单信息，以及回调函数，还有签名字段，这下不用分析了，使用了RSA签名，没看到公钥，也搞不到私钥，没办法篡改订单金额之类的。整个支付链通过后端验签+第三方回调的方式把核心完全绕过客户端，如果还需要进一步找破绽的话，可能就是看服务端的接口有没有漏洞了，或者分析第三方软件了。\n","tags":["安卓逆向"]},{"title":"oneplus6T救软砖记录","url":"/post/6279677f.html","content":"本来想刷lineageos，在豆包一顿指导下，成功变砖。后面大致跟着这个教程在救砖，但是有两个坑，记录一下1、驱动网上驱动太多了，尤其是下面这个，害人不浅，很多文章都在引用，驱动安装好还是识别不了。\nhttps://www.123pan.com/s/BTXLVv-bVJ13.html 和 https://onfix.cn/course/231 能用。2、救砖包我使用的是大侠阿木木的救砖包后面还有一个小坑就是，救砖包的工具一定要在手机连接usb之前就用管理员模式启动好。最后成功救砖。\n","tags":["刷机&改机"]},{"title":"从源码入手理解OLLVM（一）","url":"/post/1e875e93.html","content":"OLLVM（全称 Obfuscator-LLVM）是基于 LLVM 源码二次开发的开源混淆编译器框架，它通过向 LLVM 编译流程中注入自定义混淆 Pass，实现控制流平坦化、虚假控制流等多种代码混淆功能，属于 LLVM 的第三方衍生版本，要了解OLLVM，先要了解LLVM。\nclang编译器Clang 是基于 LLVM编译器基础设施 实现的主流前端编译器。说到编译器，大家最熟悉的就是GCC，那Clang(编译器)和GCC有哪些不一样呢？支持多种语言：Swift&#x2F;Rust&#x2F;Objective-C，性能优化更好，模块化设计（前、中、后端解耦）。最重要的是LLVM 的中端优化基于 SSA 形式的 LLVM IR，这一点与 GCC 的 GIMPLE SSA 在思想上是相通的。但 LLVM IR 作为稳定、对外暴露的中间表示，使得定制 Pass（如 OLLVM）在工程实现上更为友好，这会使得该编译器在常量传播、死代码消除更精准，OLLVM作为二次开发的产物，也继承这一特点。如果你有过静态分析控制流平坦化函数中某个变量的经历，很容易就能观察到，某个变量从定义到后续使用的过程中，会有大量的其余变量来接收、转移，给人一种狡兔三窟的感觉，但这并不是混淆本身，只是编译器的优化策略使然。\nSSA静态单赋值，顾名思义，就是该变量从定义开始，只能被赋值一次。举个例子：非SSA形式：\nint a = 1;    // 第一次赋值a = a + 2;    // 第二次赋值（修改原有变量）if (cond) &#123;    a = a * 3; // 第三次赋值&#125; else &#123;    a = a - 1; // 第四次赋值&#125;printf(a);\nSSA形式\nint a1 = 1;                  // 初始赋值（版本1）int a2 = a1 + 2;             // 新变量a2承载修改后的值（版本2）if (cond) &#123;    int a3 = a2 * 3;         // 分支1：新变量a3（版本3）&#125; else &#123;    int a4 = a2 - 1;         // 分支2：新变量a4（版本4）&#125;int a5 = φ(a3, a4);          // φ函数：根据执行路径选择a3或a4，赋值给a5（版本5）printf(a5);\n这样操作有个好处，就是通过静态分析就能观察到变量的变化和赋值情况，观察到a5变量就意味着前面已经被赋值了4次。\nAST(抽象语法树)LLVM编译器中clang会将源码解析出树状结构eg:代码：\nwhile b ≠ 0:    if a &gt; b:        a := a - b    else:        b := b - areturn a\n树形：\n```plaintext语句序列├─ while循环│  ├─ 循环条件│  │  ├─ 比较运算符：!=│  │  ├─ 变量名：b│  │  └─ 常量值：0│  └─ 循环体│     └─ 分支（if-else）│        ├─ 分支条件│        │  ├─ 比较运算符：&gt;│        │  ├─ 变量名：a│        │  └─ 变量名：b│        ├─ if分支体│        │  └─ 赋值语句│        │     ├─ 变量名：a│        │     └─ 二元运算符：-│        │        ├─ 变量名：a│        │        └─ 变量名：b│        └─ else分支体│           └─ 赋值语句│              ├─ 变量名：b│              └─ 二元运算符：-│                 ├─ 变量名：b│                 └─ 变量名：a└─ 返回语句   └─ 变量名：a\nBasic Block(基本块)基本块是编译器根据AST转化出IR的同时，根据一些规则，同时划分出基本块：**唯一入口、遇到跳转或者返回（ret）会形成新的块，ida中cfg的代码块的划分也是基于这个规则。\nIR（中间表达）IR是编译过程中沟通源码与汇编的一种中间抽象语言表达，不仅仅是语法表示还有基本块这个骨架。有以下作用：\n\n解耦 “前端（源码）” 和 “后端（机器码）”，实现跨语言、跨架构编译。\n作为 “编译优化的统一载体”，实现高效、通用的代码优化。eg:a1=1 → a2=a1+2 会被优化为 a2=3\n降低编译器扩展 &#x2F; 定制的复杂度。ollvm就是在这个阶段加入的混淆GCC、LLVM都具有中间表达这种概念，但是LLVM是暴露开放的，有单独的中间文件，GCC相反。IR中间表达继承了前端源码的语义，以类汇编的语法进行表达，才沟通起了整个编译过程的始末。\n\n微码（mc），ida反编译过程中的一种中间表达，后面D810反混淆原理要进一步了解。\n","tags":["混淆"]},{"title":"校园跑方案（同天智慧树）","url":"/post/run.html","content":"1.准备a.文件包\nhttps://pan.baidu.com/s/1_strslbhAKRHQD4s8Q1ePQ?pwd=f3hj\nb.雷电模拟器（其他模拟器应该也可以）\n2.正式开始\na.右上角：软件设置-&gt;磁盘-&gt;系统盘设置（选择可写入）&amp;&amp;其他-&gt;root权限打开\nb.安装好magisk*(如果有困难，就使用面具鸭（上面文件里有）协助安装)、*运动模拟器、微信、手机控制也可以安装好（雷电模拟器界面右上角）\nc.打开运动模拟器：\n\n\n下载websockt，将其从禁用拖进启用\nd.把文件包里的Lsposed拖进雷电模拟器，\n\nLsposed安装教程：https://magiskcn.com/lsposed-install#google_vignette\n如果你能创建快捷窗口最好，不能的话就看我怎么做：\n\n点击箭头所指处，打开。\n\n\n这就好了。\n3.如何使用：\n可以把模拟器切成平板，这样就不用微信在模拟器和手机之间反复切了\n模拟器中微信正常登陆\n运动模拟器中，设置-&gt;地图-&gt;改成高德地图\n运动模拟器中-&gt;绘制路径-&gt;要在那个操场跑就画在哪个操场\n运动模拟器中-&gt;模拟-&gt;设置跑步参数-&gt;开启模拟\n微信打开通天智慧-&gt;启动就可以了\n\n当然还是需要去扫脸，这就需要用到前面说的手机控制了，当然你也可以在寝室开启之后再跑到操场刷脸。\n","tags":["其他"]},{"title":"从源码入手理解OLLVM（三）","url":"/post/638f1119.html","content":"D810是很好的OLLVM反混淆插件，关于D810是如何工作的，这里有两篇很好的文档，D810: A journey into control flow unflattening、D810: Creating an extensible deobfuscation plugin for IDA Pro\n从D810的插件源码里可以看到，D810实现了两个优化器，一个是指令优化器，一个是代码块优化器，指令优化主要目的是针对前面的OLLVM-指令替换混淆，但是，事实上ida的微码本身就有一定的反混淆和指令优化的功能，下面这个是ida终端的显示：作为针对OLLVM反混淆的插件，D810的指令优化器的作用已经大幅下降，我们可以从一个时间线上窥见一二，2017年左右OLLVM官方版本就开始停止更新，同年，IDA对微码进行重大升级，显著增强了对混淆代码的分析能力。\nD810 使用 IDA Pro 的 optblock_t 接口实现基本块优化，主要处理控制流平坦化。\n反控制流平坦化流程1. 调度器检测# 在optimize方法中检测调度器self.retrieve_all_dispatchers()\n2. 反平坦化核心def remove_flattening(self) -&gt; int:    # 确保调度器父块可以直接访问    self.ensure_all_dispatcher_fathers_are_direct()        for dispatcher_info in self.dispatcher_list:        # 确保父块状态变量可解析        for dispatcher_father in dispatcher_father_list:            self.ensure_dispatcher_father_is_resolvable(dispatcher_father, dispatcher_info.entry_block)                    # 解析每个父块的真实跳转目标        for dispatcher_father in dispatcher_father_list:            self.resolve_dispatcher_father(dispatcher_father, dispatcher_info)\n\n3. 模拟执行确定目标def resolve_dispatcher_father(self, dispatcher_father, dispatcher_info):    # 获取父块历史信息    histories = self.get_dispatcher_father_histories(...)        # 模拟执行调度器确定真实目标    target_blk, disp_ins = dispatcher_info.emulate_dispatcher_with_father_history(histories[0])        # 修改控制流，绕过调度器    if len(ins_to_copy) &gt; 0:        # 创建中间块容纳副作用指令        change_1way_block_successor(dispatcher_father, dispatcher_side_effect_blk.serial)        change_1way_block_successor(dispatcher_side_effect_blk, target_blk.serial)    else:        # 直接跳转到目标        change_1way_block_successor(dispatcher_father, target_blk.serial)\n\nIDA微码（）IDA 微码是 Hex-Rays 反编译器使用的中间表示 (IR) 语言，位于汇编与伪代码之间，是 IDA 反编译流程的核心枢纽。它将不同架构的机器指令统一抽象，提供了更高级别、更易优化的代码表示形式。微码通过多个“成熟度阶段”进行优化，每个阶段都有各自的优化重点。在IDA9.2之前可以通过lucid插件查看整个优化过程，9.2就有官方的查看器了。\n\n\n\n成熟度名称\n核心操作（优化方向）\n用途\n\n\n\nMMAT_GENERATED\n从汇编指令直接翻译为微码，无优化\n作为后续所有优化的 “原始基础”，保留汇编的所有操作细节（如栈 &#x2F; 寄存器操作）\n\n\nMMAT_LOCOPT\n单个基本块内的局部优化：常量折叠、冗余指令消除、表达式化简（如 a+0→a）、死代码删除\n精简单个块内的代码，提升微码简洁度，是反混淆中 “指令级化简” 的核心阶段\n\n\nMMAT_CALLS\n专门处理函数调用逻辑：解析传参方式（栈 &#x2F; 寄存器）、统一返回值处理、内联简单函数\n让函数调用更贴近高级语言表现，为后续全局优化梳理调用关系\n\n\nMMAT_GLOBPT1&#x2F;2&#x2F;3\n全局优化的 3 个递进轮次：跨基本块的常量传播、全局死代码消除、控制流简化（合并冗余分支）、识别循环结构\n从 “整个函数” 的维度精简逻辑，初步识别 &#x2F; 消除跨块的混淆结构（如不透明谓词）\n\n\nMMAT_LVARS\n局部变量分配：将寄存器 &#x2F; 临时值映射为高级语言变量、推断变量类型与作用域\n微码优化的最后阶段，为生成 C 风格伪代码（CTree）做准备，让结果更贴近原始源码\n\n\nD810使用IDA中快捷键“Ctrl+Shift+D”打开D810\n\n点击上面的Edit：\n\n根据需要选择，也可以全选上，D810会自动匹配。指令优化器可以添加新规则。点击Start后，在目标函数使用F5后D810就能正常工作了，可以处理控制流平坦化+虚假控制流，但是D810没办法处理魔改过的Flating。\n","tags":["混淆"]},{"title":"从源码入手理解OLLVM（二）","url":"/post/2e91b24b.html","content":"OLLVMFlatteningPasses\\Obfuscation\\Flattening.cpp控制流平坦化，这是最常见的一种ollvm混淆。其中有这些概念：\n\n序言块，origBB.begin\n分发块，SwDefault、dispatchBB\n真实块，origBB\n返回块，returnBB这些都是基础块，只是根据在控制流平坦化的中的作用进行分类。主要流程是：基于 LLVM 划分的基本块进行处理，首先区分入口序言块与其余真实基本块；其次对序言块进行规范化处理，若序言块的结束是条件跳转，则将其截断并拆分出新的基本块，使序言块的出口始终为无条件跳转。随后创建分发块（dispatchBB）与返回块（returnBB），并将序言块的控制流重定向至 dispatchBB。在序言块中分配并初始化一个状态变量，用于表示当前应执行的基本块；在 dispatchBB 中加载该状态变量，并通过 switch 语句根据其取值分发至对应的真实基本块。接着将所有真实基本块统一移动至 returnBB 之前，并为每个基本块分配一个唯一的 case 值，注册到 switch 表中。随后重写各真实基本块的出口逻辑：对于原本为无条件跳转的基本块，删除原有跳转指令，改为写入其后继基本块对应的 case 值并无条件跳转至 returnBB；对于原本为条件跳转的基本块，使用 select 指令根据原条件选择不同的 case 值写入状态变量，再无条件跳转至 returnBB。最终通过 returnBB 回到 dispatchBB，形成以状态变量驱动的统一调度循环，并在末尾修复 PHI 节点与 SSA 相关问题，保证语义等价。以下是源码：\n\nbool FlatteningPass::flatten(Function &amp;F) &#123;    // 基本块数量不超过1则无需平坦化    if(F.size() &lt;= 1)&#123;        //outs() &lt;&lt; &quot;\\033[0;33mFunction size is lower then one\\033[0m\\n&quot;; // warning        return false;    &#125;    // 函数名称为$basic_ostream则不进行平坦化    if (F.getName().str().find(&quot;$basic_ostream&quot;) != std::string::npos) &#123;      outs() &lt;&lt; &quot;[obf] force_nofla: &quot; &lt;&lt; F.getName().str().c_str() &lt;&lt; &quot;\\n&quot;;      return false;    &#125;    // 将除入口块（第一个基本块）以外的基本块保存到一个 vector 容器中，便于后续处理    // 首先保存所有基本块    vector&lt;BasicBlock*&gt; origB    for(BasicBlock &amp;BB: F)&#123;        origBB.push_back(&amp;BB);    &#125;    // 从vector中去除第一个基本块    origBB.erase(origBB.begin());    BasicBlock &amp;entryBB = F.getEntryBlock();    // 如果第一个基本块的末尾是条件跳转，单独分离    bool bEntryBB_isConditional = false;    if(BranchInst *br = dyn_cast&lt;BranchInst&gt;(entryBB.getTerminator()))&#123;        if(br-&gt;isConditional())&#123;            BasicBlock *newBB = entryBB.splitBasicBlock(br, &quot;newBB&quot;);            origBB.insert(origBB.begin(), newBB);            bEntryBB_isConditional = true;        &#125;    &#125;      // 创建分发块和返回块    BasicBlock *dispatchBB = BasicBlock::Create(*CONTEXT, &quot;dispatchBB&quot;, &amp;F, &amp;entryBB);    BasicBlock *returnBB = BasicBlock::Create(*CONTEXT, &quot;returnBB&quot;, &amp;F, &amp;entryBB);    BranchInst::Create(dispatchBB, returnBB);    entryBB.moveBefore(dispatchBB);        // 去除第一个基本块末尾的跳转    if (bEntryBB_isConditional) &#123;        entryBB.getTerminator()-&gt;eraseFromParent();    &#125;    // 使第一个基本块跳转到dispatchBB    BranchInst *brDispatchBB = BranchInst::Create(dispatchBB, &amp;entryBB);      // 在入口块插入alloca和store指令创建并初始化switch变量，初始值为随机值    int randNumCase = rand();    AllocaInst *swVarPtr = new AllocaInst(TYPE_I32, 0, &quot;swVar.ptr&quot;, brDispatchBB);    new StoreInst(CONST_I32(randNumCase), swVarPtr, brDispatchBB);        // 在分发块插入load指令读取switch变量    LoadInst *swVar = new LoadInst(TYPE_I32, swVarPtr, &quot;swVar&quot;, false, dispatchBB);    // 在分发块插入switch指令实现基本块的调度    BasicBlock *swDefault = BasicBlock::Create(*CONTEXT, &quot;swDefault&quot;, &amp;F, returnBB);    BranchInst::Create(returnBB, swDefault);    SwitchInst *swInst = SwitchInst::Create(swVar, swDefault, 0, dispatchBB);    // 将原基本块插入到返回块之前，并分配case值    for(BasicBlock *BB : origBB)&#123;        BB-&gt;moveBefore(returnBB);        swInst-&gt;addCase(CONST_I32(randNumCase), BB);        randNumCase = rand();    &#125;        // 在每个基本块最后添加修改switch变量的指令和跳转到返回块的指令    for(BasicBlock *BB : origBB)&#123;        // retn BB        if(BB-&gt;getTerminator()-&gt;getNumSuccessors() == 0)&#123;            continue;        &#125;        // 非条件跳转        else if(BB-&gt;getTerminator()-&gt;getNumSuccessors() == 1)&#123;            BasicBlock *sucBB = BB-&gt;getTerminator()-&gt;getSuccessor(0);            BB-&gt;getTerminator()-&gt;eraseFromParent();            ConstantInt *numCase = swInst-&gt;findCaseDest(sucBB);            new StoreInst(numCase, swVarPtr, BB);            BranchInst::Create(returnBB, BB);        &#125;        // 条件跳转        else if(BB-&gt;getTerminator()-&gt;getNumSuccessors() == 2)&#123;            // BranchInst *br = cast&lt;BranchInst&gt;(BB-&gt;getTerminator());            BranchInst *br = dyn_cast&lt;BranchInst&gt;(BB-&gt;getTerminator());            if (!br) &#123;              //outs() &lt;&lt; &quot;[FAILED] dyn_cast&lt;BranchInst&gt;(BB-&gt;getTerminator()); &quot; &lt;&lt; BB-&gt;getName() &lt;&lt; &quot;\\n&quot;;              continue;            &#125;            if (!br-&gt;isConditional()) &#123;              //outs() &lt;&lt; &quot;[FAILED] br-&gt;isConditional(); &quot; &lt;&lt; BB-&gt;getName() &lt;&lt; &quot;\\n&quot;;              continue;            &#125;            ConstantInt *numCaseTrue = swInst-&gt;findCaseDest(BB-&gt;getTerminator()-&gt;getSuccessor(0));            ConstantInt *numCaseFalse = swInst-&gt;findCaseDest(BB-&gt;getTerminator()-&gt;getSuccessor(1));            SelectInst *sel = SelectInst::Create(br-&gt;getCondition(), numCaseTrue, numCaseFalse, &quot;&quot;, BB-&gt;getTerminator());            BB-&gt;getTerminator()-&gt;eraseFromParent();            new StoreInst(sel, swVarPtr, BB);            BranchInst::Create(returnBB, BB);        &#125;    &#125;    fixStack(F); // 修复逃逸变量和PHI指令    return true;&#125;\n看一下实际效果：\n是一个很标致的结构\nBogus Control Flow虚假控制流，\n第一步：主入口函数 runPreservedAnalyses BogusControlFlowPass::run(Function&amp; F, FunctionAnalysisManager&amp; AM) &#123;  // 检查参数有效性  if (ObfTimes &lt;= 0)&#123;    errs() &lt;&lt; &quot;BogusControlFlow application number -bcf_loop=x must be x &gt; 0&quot;;    return PreservedAnalyses::all();  &#125;  if (!((ObfProbRate &gt; 0) &amp;&amp; (ObfProbRate &lt;= 100))) &#123;    errs() &lt;&lt; &quot;BogusControlFlow application basic blocks percentage &quot;              &quot;-bcf_prob=x must be 0 &lt; x &lt;= 100&quot;;    return PreservedAnalyses::all();  &#125;  // 检查是否对该函数启用混淆  if (toObfuscate(flag, &amp;F, &quot;bcf&quot;))&#123;    bogus(F);    doF(*F.getParent(), F);    return PreservedAnalyses::none();  &#125;  return PreservedAnalyses::all();&#125;\n第二步：主要混淆逻辑 bogusvoid BogusControlFlowPass::bogus(Function &amp;F) &#123;  // 初始化统计信息  ++NumFunction;  int NumBasicBlocks = 0;  bool firstTime = true;  bool hasBeenModified = false;    // 获取混淆参数  DEBUG_WITH_TYPE(&quot;opt&quot;,                  errs() &lt;&lt; &quot;bcf: Started on function &quot; &lt;&lt; F.getName() &lt;&lt; &quot;\\n&quot;);  DEBUG_WITH_TYPE(&quot;opt&quot;,                  errs() &lt;&lt; &quot;bcf: Probability rate: &quot; &lt;&lt; ObfProbRate &lt;&lt; &quot;\\n&quot;);                    // 循环执行混淆多次（根据 ObfTimes 参数）  NumTimesOnFunctions = ObfTimes;  int NumObfTimes = ObfTimes;  do &#123;    // 遍历函数中的所有基本块    std::list&lt;BasicBlock *&gt; basicBlocks;    for (Function::iterator i = F.begin(); i != F.end(); ++i) &#123;      basicBlocks.push_back(&amp;*i);    &#125;    while (!basicBlocks.empty()) &#123;      NumBasicBlocks++;      // 根据概率决定是否对当前基本块进行混淆      if ((int)llvm::cryptoutils-&gt;get_range(100) &lt;= ObfProbRate) &#123;        DEBUG_WITH_TYPE(&quot;opt&quot;, errs() &lt;&lt; &quot;bcf: Block &quot; &lt;&lt; NumBasicBlocks                                      &lt;&lt; &quot; selected. \\n&quot;);        hasBeenModified = true;        ++NumModifiedBasicBlocks;        NumAddedBasicBlocks += 3;        FinalNumBasicBlocks += 3;        // 对选中的基本块应用虚假控制流        BasicBlock *basicBlock = basicBlocks.front();        addBogusFlow(basicBlock, F);      &#125; else &#123;        DEBUG_WITH_TYPE(&quot;opt&quot;, errs() &lt;&lt; &quot;bcf: Block &quot; &lt;&lt; NumBasicBlocks                                      &lt;&lt; &quot; not selected.\\n&quot;);      &#125;      basicBlocks.pop_front();      if (firstTime) &#123;        ++InitNumBasicBlocks;        ++FinalNumBasicBlocks;      &#125;    &#125;    firstTime = false;  &#125; while (--NumObfTimes &gt; 0);&#125;\n\n第三步：添加虚假控制流 addBogusFlowvoid BogusControlFlowPass::addBogusFlow(BasicBlock *basicBlock, Function &amp;F) &#123;  // 1. 分割基本块  BasicBlock::iterator i1 = basicBlock-&gt;begin();  if (basicBlock-&gt;getFirstNonPHIOrDbgOrLifetime())    i1 = (BasicBlock::iterator)basicBlock-&gt;getFirstNonPHIOrDbgOrLifetime();  if (basicBlock-&gt;getFirstNonPHI()-&gt;isEHPad())    return;      // 将原基本块分割为两部分  Twine *var = new Twine(&quot;originalBB&quot;);  BasicBlock *originalBB = basicBlock-&gt;splitBasicBlock(i1, *var);  DEBUG_WITH_TYPE(&quot;gen&quot;, errs()                             &lt;&lt; &quot;bcf: First and original basic blocks: ok\\n&quot;);  // 2. 创建修改后的虚假基本块  Twine *var3 = new Twine(&quot;alteredBB&quot;);  BasicBlock *alteredBB = createAlteredBasicBlock(originalBB, *var3, &amp;F);  DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Altered basic block: ok\\n&quot;);  // 3. 移除原有终止指令  alteredBB-&gt;getTerminator()-&gt;eraseFromParent();  basicBlock-&gt;getTerminator()-&gt;eraseFromParent();  // 4. 创建条件判断  Value *LHS = ConstantFP::get(Type::getFloatTy(F.getContext()), 1.0);  Value *RHS = ConstantFP::get(Type::getFloatTy(F.getContext()), 1.0);    // 创建始终为真的条件 (FCMP_TRUE)  Twine *var4 = new Twine(&quot;condition&quot;);  FCmpInst *condition =      new FCmpInst(*basicBlock, FCmpInst::FCMP_TRUE, LHS, RHS, *var4);  // 5. 创建分支指令  // 如果条件为真，跳转到原始基本块；否则跳转到虚假基本块  BranchInst::Create(originalBB, alteredBB, (Value *)condition, basicBlock);    // 虚假基本块跳转回原始基本块  BranchInst::Create(originalBB, alteredBB);  // 6. 进一步处理原始基本块的终止部分  BasicBlock::iterator i = originalBB-&gt;end();  Twine *var5 = new Twine(&quot;originalBBpart2&quot;);  BasicBlock *originalBBpart2 = originalBB-&gt;splitBasicBlock(--i, *var5);  originalBB-&gt;getTerminator()-&gt;eraseFromParent();    // 创建另一个始终为真的条件  Twine *var6 = new Twine(&quot;condition2&quot;);  FCmpInst *condition2 =      new FCmpInst(*originalBB, CmpInst::FCMP_TRUE, LHS, RHS, *var6);  BranchInst::Create(originalBBpart2, alteredBB, (Value *)condition2, originalBB);&#125;\n\n第四步：创建修改后的基本块 createAlteredBasicBlockBasicBlock *createAlteredBasicBlock(BasicBlock *basicBlock, const Twine &amp;Name, Function *F) &#123;  // 1. 克隆基本块  ValueToValueMapTy VMap;  BasicBlock *alteredBB = llvm::CloneBasicBlock(basicBlock, VMap, Name, F);  DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Original basic block cloned\\n&quot;);    // 2. 重新映射操作数和元数据  BasicBlock::iterator ji = basicBlock-&gt;begin();  for (BasicBlock::iterator i = alteredBB-&gt;begin(), e = alteredBB-&gt;end();       i != e; ++i) &#123;    // 映射操作数    for (User::op_iterator opi = i-&gt;op_begin(), ope = i-&gt;op_end(); opi != ope;         ++opi) &#123;      Value *v = MapValue(*opi, VMap, RF_None, 0);      if (v != 0) &#123;        *opi = v;      &#125;    &#125;    // 映射 PHI 节点    if (PHINode *pn = dyn_cast&lt;PHINode&gt;(i)) &#123;      for (unsigned j = 0, e = pn-&gt;getNumIncomingValues(); j != e; ++j) &#123;        Value *v = MapValue(pn-&gt;getIncomingBlock(j), VMap, RF_None, 0);        if (v != 0) &#123;          pn-&gt;setIncomingBlock(j, cast&lt;BasicBlock&gt;(v));        &#125;      &#125;    &#125;    // 映射调试信息    i-&gt;setDebugLoc(ji-&gt;getDebugLoc());    ji++;  &#125;  // 3. 在克隆的基本块中添加垃圾指令  for (BasicBlock::iterator i = alteredBB-&gt;begin(), e = alteredBB-&gt;end();       i != e; ++i) &#123;    // 对二元操作进行处理    if (i-&gt;isBinaryOp()) &#123;      unsigned opcode = i-&gt;getOpcode();      Instruction *op, *op1 = NULL;      Twine *var = new Twine(&quot;_&quot;);            // 根据操作码类型添加不同的垃圾指令      if (opcode == Instruction::Add || opcode == Instruction::Sub ||          opcode == Instruction::Mul || opcode == Instruction::UDiv ||          // ... 其他整数操作          ) &#123;        // 随机添加垃圾指令        for (int random = (int)llvm::cryptoutils-&gt;get_range(10); random &lt; 10;             ++random) &#123;          switch (llvm::cryptoutils-&gt;get_range(4)) &#123;          case 0: // 什么都不做            break;          case 1: // 添加负数操作            op = BinaryOperator::CreateNeg(i-&gt;getOperand(0), *var, &amp;*i);            op1 = BinaryOperator::Create(Instruction::Add, op, i-&gt;getOperand(1),                                         &quot;gen&quot;, &amp;*i);            break;          case 2: // 添加减法和乘法操作            op1 = BinaryOperator::Create(Instruction::Sub, i-&gt;getOperand(0),                                         i-&gt;getOperand(1), *var, &amp;*i);            op = BinaryOperator::Create(Instruction::Mul, op1, i-&gt;getOperand(1),                                        &quot;gen&quot;, &amp;*i);            break;          case 3: // 添加移位操作            op = BinaryOperator::Create(Instruction::Shl, i-&gt;getOperand(0),                                        i-&gt;getOperand(1), *var, &amp;*i);            break;          &#125;        &#125;      &#125;      // 类似处理浮点操作和其他指令类型    &#125;  &#125;  return alteredBB;&#125;\n\n第五步：最终处理 doFbool BogusControlFlowPass::doF(Module &amp;M, Function &amp;F) &#123;  // 将明显为真的条件 (FCMP_TRUE) 替换为不那么明显的复杂表达式  // 例如，将 FCMP_TRUE 替换为 &quot;(y &lt; 10 || x * (x + 1) % 2 == 0)&quot;    // 1. 创建两个全局变量 x 和 y  Twine *varX = new Twine(&quot;x&quot;);  Twine *varY = new Twine(&quot;y&quot;);  Value *x1 = ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false);  Value *y1 = ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false);  GlobalVariable *x =      new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false,                         GlobalValue::CommonLinkage, (Constant *)x1, *varX);  GlobalVariable *y =      new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false,                         GlobalValue::CommonLinkage, (Constant *)y1, *varY);  // 2. 查找所有 FCMP_TRUE 条件  std::vector&lt;Instruction *&gt; toEdit, toDelete;  for (Function::iterator fi = F.begin(), fe = F.end(); fi != fe; ++fi) &#123;    Instruction *tbb = fi-&gt;getTerminator();    if (tbb-&gt;getOpcode() == Instruction::Br) &#123;      BranchInst *br = (BranchInst *)(tbb);      if (br-&gt;isConditional()) &#123;        FCmpInst *cond = (FCmpInst *)br-&gt;getCondition();        unsigned opcode = cond-&gt;getOpcode();        if (opcode == Instruction::FCmp) &#123;          if (cond-&gt;getPredicate() == FCmpInst::FCMP_TRUE) &#123;            toDelete.push_back(cond);            toEdit.push_back(tbb);          &#125;        &#125;      &#125;    &#125;  &#125;  // 3. 替换条件为复杂表达式  for (std::vector&lt;Instruction *&gt;::iterator i = toEdit.begin();       i != toEdit.end(); ++i) &#123;    // 构造复杂条件: y &lt; 10 || x*(x+1) % 2 == 0    opX = new LoadInst(Type::getInt32Ty(M.getContext()), (Value *)x, &quot;&quot;, (*i));    opY = new LoadInst(Type::getInt32Ty(M.getContext()), (Value *)y, &quot;&quot;, (*i));    // 计算 x*(x+1) % 2    op = BinaryOperator::Create(        Instruction::Sub, (Value *)opX,        ConstantInt::get(Type::getInt32Ty(M.getContext()), 1, false), &quot;&quot;, (*i));    op1 = BinaryOperator::Create(Instruction::Mul, (Value *)opX, op, &quot;&quot;, (*i));    op = BinaryOperator::Create(        Instruction::URem, op1,        ConstantInt::get(Type::getInt32Ty(M.getContext()), 2, false), &quot;&quot;, (*i));            // 比较结果是否等于0    condition = new ICmpInst(        (*i), ICmpInst::ICMP_EQ, op,        ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false));            // 比较 y &lt; 10    condition2 = new ICmpInst(        (*i), ICmpInst::ICMP_SLT, opY,        ConstantInt::get(Type::getInt32Ty(M.getContext()), 10, false));            // 最终条件: (y &lt; 10) || (x*(x+1) % 2 == 0)    op1 = BinaryOperator::Create(Instruction::Or, (Value *)condition,                                 (Value *)condition2, &quot;&quot;, (*i));    // 更新分支指令    BranchInst::Create(((BranchInst *)*i)-&gt;getSuccessor(0),                       ((BranchInst *)*i)-&gt;getSuccessor(1), (Value *)op1,                       ((BranchInst *)*i)-&gt;getParent());    (*i)-&gt;eraseFromParent();  &#125;    // 删除原来的条件指令  for (std::vector&lt;Instruction *&gt;::iterator i = toDelete.begin();       i != toDelete.end(); ++i) &#123;    (*i)-&gt;eraseFromParent();  &#125;  return true;&#125;\n在实践中常爱将平坦化和其他几种混淆掺在一起使用。Flatting+Bogus Control Flow:还是能看到控制流平坦化的特点，不过明显多了很多块。\nSubstitution指令替换，这个简单一点，就是将源码中涉及到的二元运算指令替换为更复杂的表达：\n加法运算 (a = b + c)\na = b - (-c)\na = -(-b + (-c))\nr = rand(); a = b + r; a = a + c; a = a - r\nr = rand(); a = b - r; a = a + c; a = a + r\n\n减法运算 (a = b - c)\na = b + (-c)\nr = rand(); a = b + r; a = a - c; a = a - r\nr = rand(); a = b - r; a = a - c; a = a + r\n\n按位与运算 (a = b &amp; c)\na = (b ^ ~c) &amp; b\na = ~(~b | ~c) &amp; (r | ~r)\n\n按位或运算 (a = b | c)\na = (b &amp; c) | (b ^ c)\na = (((~b &amp; r) | (b &amp; ~r)) ^ ((~c &amp; r) | (c &amp; ~r))) | (~(~b | ~c) &amp; (r | ~r))\n\n按位异或运算 (a = b ^ c)\na = (~b &amp; c) | (b &amp; ~c)\na = (b ^ r) ^ (c ^ r)\n\nString Encryption字符串加密，这个在实践中也是很常见。原理：\n\n在编译时对程序中的字符串字面量进行加密处理\n将加密后的字符串存储在全局数据区\n在运行时首次使用字符串时进行解密\n后续使用解密后的字符串\n\nSplit Basic Block基本块分割\n工作原理\n遍历函数中的所有基本块\n筛选出适合分割的基本块（不含PHI节点且指令数大于1）\n在基本块内部随机选择分割点\n将基本块在分割点处分割成多个连续的基本块\n保持原有的执行顺序和逻辑关系\n\n主要函数流程PreservedAnalyses SplitBasicBlockPass::run(Function&amp; F, FunctionAnalysisManager&amp; AM) &#123;    Function *tmp = &amp;F;    // 检查该函数是否需要进行基本块分割混淆    if (toObfuscate(flag, tmp, &quot;split&quot;)) &#123;        // 执行分割操作        split(tmp);        // 更新统计信息        ++Split;        return PreservedAnalyses::none();    &#125;    return PreservedAnalyses::all();&#125;\n核心分割逻辑void SplitBasicBlockPass::split(Function *f) &#123;    // 1. 保存原始基本块列表，防止在分割过程中迭代器失效    std::vector&lt;BasicBlock *&gt; origBB;    for (Function::iterator I = f-&gt;begin(), IE = f-&gt;end(); I != IE; ++I) &#123;        origBB.push_back(&amp;*I);    &#125;        // 2. 遍历所有基本块    for (std::vector&lt;BasicBlock *&gt;::iterator I = origBB.begin(), IE = origBB.end();         I != IE; ++I) &#123;        BasicBlock *curr = *I;        int splitN = SplitNum; // 默认分割次数为3                // 3. 筛选可分割的基本块        // 跳过指令数小于2或包含PHI节点的基本块        if (curr-&gt;size() &lt; 2 || containsPHI(curr)) &#123;            continue;        &#125;                // 4. 调整分割次数        // 如果指定的分割次数大于等于基本块大小，则调整为基本块大小-1        if ((size_t)splitN &gt;= curr-&gt;size()) &#123;            splitN = curr-&gt;size() - 1;        &#125;                // 5. 生成分割点        std::vector&lt;int&gt; test;        // 将所有可能的分割点位置加入向量（除了第一个位置）        for (unsigned i = 1; i &lt; curr-&gt;size(); ++i) &#123;            test.push_back(i);        &#125;                // 6. 随机打乱分割点顺序        if (test.size() != 1) &#123;            shuffle(test);            // 对前splitN个分割点进行排序，确保按顺序分割            std::sort(test.begin(), test.begin() + splitN);        &#125;                // 7. 执行分割操作        BasicBlock::iterator it = curr-&gt;begin();        BasicBlock *toSplit = curr;        int last = 0;        for (int i = 0; i &lt; splitN; ++i) &#123;            // 如果当前要分割的基本块太小则跳过            if (toSplit-&gt;size() &lt; 2) &#123;                continue;            &#125;                        // 移动迭代器到分割点位置            for (int j = 0; j &lt; test[i] - last; ++j) &#123;                ++it;            &#125;            last = test[i];                        // 在当前位置分割基本块            toSplit = toSplit-&gt;splitBasicBlock(it, toSplit-&gt;getName() + &quot;.split&quot;);        &#125;        ++Split;    &#125;&#125;\n辅助函数分析// 检查基本块是否包含PHI节点bool SplitBasicBlockPass::containsPHI(BasicBlock *BB) &#123;    for (Instruction &amp;I : *BB) &#123;        if (isa&lt;PHINode&gt;(&amp;I)) &#123;            return true;        &#125;    &#125;    return false;&#125;// 随机打乱向量中的元素顺序void SplitBasicBlockPass::shuffle(std::vector&lt;int&gt; &amp;vec) &#123;    int n = vec.size();    for (int i = n - 1; i &gt; 0; --i) &#123;        std::swap(vec[i], vec[cryptoutils-&gt;get_uint32_t() % (i + 1)]);    &#125;&#125;\n\nIndirect Call间接调用\n工作原理\n识别函数中的所有直接函数调用\n为每个被调用的函数分配唯一的编号\n创建一个全局数组，存储所有被调用函数的地址\n将直接调用替换为通过数组索引访问函数地址的间接调用\n使用加密技术进一步隐藏函数地址信息\n\n核心混淆逻辑bool IndirectCallPass::doIndirctCall(Function &amp;Fn)&#123;    // 检查是否跳过该函数    if (Options &amp;&amp; Options-&gt;skipFunction(Fn.getName())) &#123;        return false;    &#125;    LLVMContext &amp;Ctx = Fn.getContext();    // 清空之前的数据结构    CalleeNumbering.clear();    Callees.clear();    CallSites.clear();    // 为函数中的所有被调用函数编号    NumberCallees(Fn);    // 如果没有调用任何函数，则直接返回    if (Callees.empty()) &#123;        return false;    &#125;    // 生成随机密钥用于地址加密    uint64_t V = RandomEngine.get_uint64_t();    IntegerType *intType = Type::getInt32Ty(Ctx);    // 根据指针大小选择合适的整数类型（32位或64位）    unsigned pointerSize = Fn.getEntryBlock().getModule()-&gt;getDataLayout().getTypeAllocSize(PointerType::getUnqual(Fn.getContext()));    if (pointerSize == 8) &#123;        intType = Type::getInt64Ty(Ctx);    &#125;        // 创建加密密钥和解密密钥    ConstantInt *EncKey = ConstantInt::get(intType, V, false);    ConstantInt *EncKey1 = ConstantInt::get(intType, -V, false);    Value *MySecret = ConstantInt::get(intType, 0, true);    ConstantInt *Zero = ConstantInt::get(intType, 0);        // 创建存储函数地址的全局变量数组    GlobalVariable *Targets = getIndirectCallees(Fn, EncKey1);    // 遍历所有调用点并进行间接调用转换    for (auto CI : CallSites) &#123;        SmallVector&lt;Value *, 8&gt; Args;        SmallVector&lt;AttributeSet, 8&gt; ArgAttrVec;        CallBase *CB = CI;        Function *Callee = CB-&gt;getCalledFunction();        FunctionType *FTy = CB-&gt;getFunctionType();        IRBuilder&lt;&gt; IRB(CB);        Args.clear();        ArgAttrVec.clear();        // 获取被调用函数的编号        Value *Idx = ConstantInt::get(intType, CalleeNumbering[CB-&gt;getCalledFunction()]);                // 从全局数组中获取加密的函数地址        Value *GEP = IRB.CreateGEP(Targets-&gt;getValueType(), Targets, &#123;Zero, Idx&#125;);        LoadInst *EncDestAddr = IRB.CreateLoad(GEP-&gt;getType(), GEP, CI-&gt;getName());        // 获取调用的参数信息        const AttributeList &amp;CallPAL = CB-&gt;getAttributes();        auto I = CB-&gt;arg_begin();        unsigned i = 0;        // 收集函数调用参数        for (unsigned e = FTy-&gt;getNumParams(); i != e; ++I, ++i) &#123;          Args.push_back(*I);          AttributeSet Attrs = CallPAL.getParamAttrs(i);          ArgAttrVec.push_back(Attrs);        &#125;        for (auto E = CB-&gt;arg_end(); I != E; ++I, ++i) &#123;          Args.push_back(*I);          ArgAttrVec.push_back(CallPAL.getParamAttrs(i));        &#125;        // 解密函数地址        Value *Secret = IRB.CreateAdd(EncKey, MySecret);        Value *DestAddr = IRB.CreateGEP(Type::getInt8Ty(Ctx), EncDestAddr, Secret);        // 将地址转换为函数指针类型        Value *FnPtr = IRB.CreateBitCast(DestAddr, FTy-&gt;getPointerTo());        FnPtr-&gt;setName(&quot;Call_&quot; + Callee-&gt;getName());                // 替换原来的直接调用为间接调用        CB-&gt;setCalledOperand(FnPtr);    &#125;    return true;&#125;\n辅助函数// 创建存储函数地址的全局变量数组GlobalVariable *IndirectCallPass::getIndirectCallees(Function &amp;F, ConstantInt *EncKey)&#123;    // 构造全局变量名称    std::string GVName(F.getName().str() + &quot;_IndirectCallees&quot;);        // 检查是否已经创建过该全局变量    GlobalVariable *GV = F.getParent()-&gt;getNamedGlobal(GVName);    if (GV)&#123;        return GV;    &#125;        // 为每个被调用函数创建加密的地址条目    std::vector&lt;Constant *&gt; Elements;    for (auto Callee : Callees)&#123;        // 将函数地址强制转换为int8指针        Constant *CE = ConstantExpr::getBitCast(Callee, llvm::PointerType::get(Type::getInt8Ty(F.getContext()),0));        // 使用密钥对地址进行加密（通过GEP实现地址偏移）        CE = ConstantExpr::getGetElementPtr(Type::getInt8Ty(F.getContext()), CE, EncKey);        Elements.push_back(CE);    &#125;        // 创建数组类型和常量数组    ArrayType *ATy = ArrayType::get(llvm::PointerType::get(Type::getInt8Ty(F.getContext()),0), Elements.size());    Constant *CA = ConstantArray::get(ATy, ArrayRef&lt;Constant *&gt;(Elements));        // 创建全局变量存储函数地址数组    GV = new GlobalVariable(*F.getParent(), ATy, false, GlobalValue::LinkageTypes::PrivateLinkage, CA, GVName);    appendToCompilerUsed(*F.getParent(), &#123;GV&#125;);    return GV;&#125;// 为函数中的所有被调用函数编号void IndirectCallPass::NumberCallees(Function &amp;F)&#123;    // 遍历函数中的所有基本块和指令    for (auto &amp;BB : F)&#123;        for (auto &amp;I : BB)&#123;            // 检查是否为调用指令            if (dyn_cast&lt;CallInst&gt;(&amp;I))&#123;                CallSite CS(&amp;I);                Function *Callee = CS.getCalledFunction();                                // 跳过空函数和内建函数                if (Callee == nullptr)&#123;                    continue;                &#125;                if (Callee-&gt;isIntrinsic())&#123;                    continue;                &#125;                                // 记录调用点                CallSites.push_back((CallInst *)&amp;I);                                // 为被调用函数分配编号                if (CalleeNumbering.count(Callee) == 0)&#123;                    CalleeNumbering[Callee] = Callees.size();                    Callees.push_back(Callee);                &#125;            &#125;        &#125;    &#125;&#125;\n这种混淆和平坦化一起使用是很恐怖的：可以看到原本的函数调用部分变成了一个跳转表达，就是说静态分析完全看不出来是在干什么了。同时跳转的地址被加密保存，恐怖如斯。这种混淆在实践中常常会被误认为是vmp，但实际是ollvm的一种而已。\nIndirect Branch间接跳转，和前面的间接调用类似，不过间接调用使用函数形式包装真实块，而间接跳转只是一般跳转而已，只不过是二次解析的跳转（间接跳转）\n工作原理\n识别函数中的所有条件分支指令\n为每个分支目标基本块分配唯一的编号\n创建一个全局数组，存储所有分支目标的地址\n将直接条件分支替换为通过数组索引访问目标地址的间接跳转\n使用加密技术进一步隐藏分支目标地址信息\n\n主要函数流程PreservedAnalyses IndirectBranchPass::run(Module &amp;M, ModuleAnalysisManager &amp;AM) &#123;  if (this-&gt;flag) &#123;    outs() &lt;&lt; &quot;[Soule] force.run.IndirectBranchPass\\n&quot;;  &#125;    // 遍历模块中的所有函数  for (Function &amp;Fn : M) &#123;    // 检查该函数是否需要进行间接跳转混淆    if (toObfuscate(flag, &amp;Fn, &quot;ibr&quot;)) &#123;      // 检查是否跳过该函数      if (Options &amp;&amp; Options-&gt;skipFunction(Fn.getName())) &#123;        continue;      &#125;      // 跳过空函数、弱链接函数和初始化函数      if (Fn.empty() || Fn.hasLinkOnceLinkage() || Fn.getSection() == &quot;.text.startup&quot;) &#123;        continue;      &#125;      LLVMContext &amp;Ctx = Fn.getContext();      // 初始化成员字段      BBNumbering.clear();      BBTargets.clear();      // 分割所有关键边（因为LLVM无法从IndirectBrInst分割关键边）      SplitAllCriticalEdges(Fn, CriticalEdgeSplittingOptions(nullptr, nullptr));            // 为基本块编号      NumberBasicBlock(Fn);      // 如果没有基本块需要处理则跳过      if (BBNumbering.empty()) &#123;        continue;      &#125;      // 生成随机密钥用于地址加密      uint64_t V = RandomEngine.get_uint64_t();      IntegerType *intType = Type::getInt32Ty(Ctx);            // 根据指针大小选择合适的整数类型（32位或64位）      unsigned pointerSize = Fn.getEntryBlock().getModule()-&gt;getDataLayout().getTypeAllocSize(          PointerType::getUnqual(Fn.getContext()));      if (pointerSize == 8) &#123;        intType = Type::getInt64Ty(Ctx);      &#125;            // 创建加密密钥和解密密钥      ConstantInt *EncKey = ConstantInt::get(intType, V, false);      ConstantInt *EncKey1 = ConstantInt::get(intType, -V, false);      Value *MySecret = ConstantInt::get(intType, 0, true);      ConstantInt *Zero = ConstantInt::get(intType, 0);            // 创建存储分支目标地址的全局变量数组      GlobalVariable *DestBBs = getIndirectTargets(Fn, EncKey1);      // 遍历函数中的所有基本块，处理条件分支指令      for (auto &amp;BB : Fn) &#123;        auto *BI = dyn_cast&lt;BranchInst&gt;(BB.getTerminator());        // 检查是否为条件分支指令        if (BI &amp;&amp; BI-&gt;isConditional()) &#123;          IRBuilder&lt;&gt; IRB(BI);          // 获取条件值          Value *Cond = BI-&gt;getCondition();          Value *Idx;          Value *TIdx, *FIdx;          // 获取真分支和假分支的目标基本块编号          TIdx = ConstantInt::get(intType, BBNumbering[BI-&gt;getSuccessor(0)]);          FIdx = ConstantInt::get(intType, BBNumbering[BI-&gt;getSuccessor(1)]);                    // 根据条件值选择目标索引          Idx = IRB.CreateSelect(Cond, TIdx, FIdx);          // 从全局数组中获取加密的目标地址          Value *GEP = IRB.CreateGEP(DestBBs-&gt;getValueType(), DestBBs, &#123;Zero, Idx&#125;);          Value *EncDestAddr = IRB.CreateLoad(GEP-&gt;getType(), GEP, &quot;EncDestAddr&quot;);                    // 解密目标地址          Value *DecKey = IRB.CreateAdd(EncKey, MySecret);          Value *DestAddr = IRB.CreateGEP(Type::getInt8Ty(Ctx), EncDestAddr, DecKey);          // 创建间接跳转指令          IndirectBrInst *IBI = IndirectBrInst::Create(DestAddr, 2);          IBI-&gt;addDestination(BI-&gt;getSuccessor(0));          IBI-&gt;addDestination(BI-&gt;getSuccessor(1));                    // 用间接跳转指令替换原来的条件分支指令          ReplaceInstWithInst(BI, IBI);        &#125;      &#125;    &#125;  &#125;  return PreservedAnalyses::none();&#125;\n辅助函数实现// 为函数中的所有分支目标基本块编号void IndirectBranchPass::NumberBasicBlock(Function &amp;F) &#123;  // 遍历函数中的所有基本块，收集条件分支的目标基本块  for (auto &amp;BB : F) &#123;    if (auto *BI = dyn_cast&lt;BranchInst&gt;(BB.getTerminator())) &#123;      if (BI-&gt;isConditional()) &#123;        unsigned N = BI-&gt;getNumSuccessors();        // 遍历所有后继基本块        for (unsigned I = 0; I &lt; N; I++) &#123;          BasicBlock *Succ = BI-&gt;getSuccessor(I);          // 如果该基本块尚未编号，则添加到目标列表中          if (BBNumbering.count(Succ) == 0) &#123;            BBTargets.push_back(Succ);            BBNumbering[Succ] = 0;          &#125;        &#125;      &#125;    &#125;  &#125;  // 使用随机种子打乱基本块顺序  long seed = RandomEngine.get_uint32_t();  std::default_random_engine e(seed);  std::shuffle(BBTargets.begin(), BBTargets.end(), e);  // 为基本块分配编号  unsigned N = 0;  for (auto BB : BBTargets) &#123;    BBNumbering[BB] = N++;  &#125;&#125;// 创建存储分支目标地址的全局变量数组GlobalVariable *IndirectBranchPass::getIndirectTargets(Function &amp;F, ConstantInt *EncKey) &#123;  // 构造全局变量名称  std::string GVName(F.getName().str() + &quot;_IndirectBrTargets&quot;);  GlobalVariable *GV = F.getParent()-&gt;getNamedGlobal(GVName);    // 如果已经存在则直接返回  if (GV)    return GV;  // 为每个分支目标创建加密的地址条目  std::vector&lt;Constant *&gt; Elements;  for (const auto BB : BBTargets) &#123;    // 获取基本块地址并强制转换为int8指针    Constant *CE = ConstantExpr::getBitCast(BlockAddress::get(BB),                                           llvm::PointerType::get(Type::getInt8Ty(F.getContext()),0));    // 使用密钥对地址进行加密（通过GEP实现地址偏移）    CE = ConstantExpr::getGetElementPtr(Type::getInt8Ty(F.getContext()), CE, EncKey);    Elements.push_back(CE);  &#125;  // 创建数组类型和常量数组  ArrayType *ATy = ArrayType::get(llvm::PointerType::get(Type::getInt8Ty(F.getContext()),0), Elements.size());  Constant *CA = ConstantArray::get(ATy, ArrayRef&lt;Constant *&gt;(Elements));    // 创建全局变量存储分支目标地址数组  GV = new GlobalVariable(*F.getParent(), ATy, false,                         GlobalValue::LinkageTypes::PrivateLinkage, CA, GVName);  appendToCompilerUsed(*F.getParent(), &#123;GV&#125;);  return GV;&#125;\n看看应用：原本的函数结构看不全了，这就是间接跳转都结果。\nIndirect Global Variable全局变量间接访问\n工作原理\n识别函数中使用的所有全局变量\n为每个全局变量分配唯一的编号\n创建一个全局数组，存储所有被访问全局变量的地址\n将直接的全局变量访问替换为通过数组索引访问地址的间接访问\n使用加密技术进一步隐藏全局变量地址信息\n\n主要函数流程PreservedAnalyses IndirectGlobalVariablePass::run(Module &amp;M, ModuleAnalysisManager &amp;AM) &#123;  if (this-&gt;flag) &#123;    outs() &lt;&lt; &quot;[Soule] force.run.IndirectGlobalVariablePass\\n&quot;;  &#125;    // 遍历模块中的所有函数  for (Function &amp;Fn : M) &#123;    // 检查该函数是否需要进行全局变量间接访问混淆    if (!toObfuscate(flag, &amp;Fn, &quot;igv&quot;)) &#123;      continue;    &#125;    // 检查是否跳过该函数    if (Options &amp;&amp; Options-&gt;skipFunction(Fn.getName())) &#123;      continue;    &#125;    LLVMContext &amp;Ctx = Fn.getContext();    // 初始化成员字段    GVNumbering.clear();    GlobalVariables.clear();    // 将常量表达式降级为指令    LowerConstantExpr(Fn);        // 为全局变量编号    NumberGlobalVariable(Fn);    // 如果没有全局变量需要处理则跳过    if (GlobalVariables.empty()) &#123;      continue;    &#125;    // 生成随机密钥用于地址加密    uint64_t V = RandomEngine.get_uint64_t();    IntegerType *intType = Type::getInt32Ty(Ctx);        // 根据指针大小选择合适的整数类型（32位或64位）    unsigned pointerSize = Fn.getEntryBlock().getModule()-&gt;getDataLayout().getTypeAllocSize(        PointerType::getUnqual(Fn.getContext()));    if (pointerSize == 8) &#123;      intType = Type::getInt64Ty(Ctx);    &#125;    // 创建加密密钥和解密密钥    ConstantInt *EncKey = ConstantInt::get(intType, V, false);    ConstantInt *EncKey1 = ConstantInt::get(intType, -V, false);    Value *MySecret = ConstantInt::get(intType, 0, true);    ConstantInt *Zero = ConstantInt::get(intType, 0);        // 创建存储全局变量地址的全局变量数组    GlobalVariable *GVars = getIndirectGlobalVariables(Fn, EncKey1);    // 遍历函数中的所有指令，处理全局变量引用    for (inst_iterator I = inst_begin(Fn), E = inst_end(Fn); I != E; ++I) &#123;      Instruction *Inst = &amp;*I;            // 跳过一些特殊指令      if (isa&lt;LandingPadInst&gt;(Inst) || isa&lt;CleanupPadInst&gt;(Inst) ||          isa&lt;CatchPadInst&gt;(Inst) || isa&lt;CatchReturnInst&gt;(Inst) ||          isa&lt;CatchSwitchInst&gt;(Inst) || isa&lt;ResumeInst&gt;(Inst) ||          isa&lt;CallInst&gt;(Inst)) &#123;        continue;      &#125;            // 处理PHI节点      if (PHINode *PHI = dyn_cast&lt;PHINode&gt;(Inst)) &#123;        for (unsigned int i = 0; i &lt; PHI-&gt;getNumIncomingValues(); ++i) &#123;          Value *val = PHI-&gt;getIncomingValue(i);          // 检查PHI节点的输入值是否为全局变量          if (GlobalVariable *GV = dyn_cast&lt;GlobalVariable&gt;(val)) &#123;            // 检查该全局变量是否已编号            if (GVNumbering.count(GV) == 0) &#123;              continue;            &#125;            // 获取PHI节点所在基本块的终止指令作为插入点            Instruction *IP = PHI-&gt;getIncomingBlock(i)-&gt;getTerminator();            IRBuilder&lt;&gt; IRB(IP);            // 获取全局变量编号            Value *Idx = ConstantInt::get(intType, GVNumbering[GV]);                        // 从全局数组中获取加密的全局变量地址            Value *GEP = IRB.CreateGEP(GVars-&gt;getValueType(), GVars, &#123;Zero, Idx&#125;);            LoadInst *EncGVAddr = IRB.CreateLoad(GEP-&gt;getType(), GEP, GV-&gt;getName());            // 解密全局变量地址            Value *Secret = IRB.CreateAdd(EncKey, MySecret);            Value *GVAddr = IRB.CreateGEP(Type::getInt8Ty(Ctx), EncGVAddr, Secret);                        // 将地址转换为正确的类型            GVAddr = IRB.CreateBitCast(GVAddr, GV-&gt;getType());            GVAddr-&gt;setName(&quot;IndGV0_&quot;);                        // 替换PHI节点中的全局变量引用            PHI-&gt;setIncomingValue(i, GVAddr);          &#125;        &#125;      &#125; else &#123;        // 处理普通指令的操作数        for (User::op_iterator op = Inst-&gt;op_begin(); op != Inst-&gt;op_end(); ++op) &#123;          // 检查操作数是否为全局变量          if (GlobalVariable *GV = dyn_cast&lt;GlobalVariable&gt;(*op)) &#123;            // 检查该全局变量是否已编号            if (GVNumbering.count(GV) == 0) &#123;              continue;            &#125;            IRBuilder&lt;&gt; IRB(Inst);                        // 获取全局变量编号            Value *Idx = ConstantInt::get(intType, GVNumbering[GV]);                        // 从全局数组中获取加密的全局变量地址            Value *GEP = IRB.CreateGEP(GVars-&gt;getValueType(), GVars, &#123;Zero, Idx&#125;);            LoadInst *EncGVAddr = IRB.CreateLoad(GEP-&gt;getType(), GEP, GV-&gt;getName());            // 解密全局变量地址            Value *Secret = IRB.CreateAdd(EncKey, MySecret);            Value *GVAddr = IRB.CreateGEP(Type::getInt8Ty(Ctx), EncGVAddr, Secret);                        // 将地址转换为正确的类型            GVAddr = IRB.CreateBitCast(GVAddr, GV-&gt;getType());            GVAddr-&gt;setName(&quot;IndGV1_&quot;);                        // 替换指令中的全局变量引用            Inst-&gt;replaceUsesOfWith(GV, GVAddr);          &#125;        &#125;      &#125;    &#125;  &#125;  return PreservedAnalyses::none();&#125;\n辅助函数实现// 为函数中使用的所有全局变量编号void IndirectGlobalVariablePass::NumberGlobalVariable(Function &amp;F) &#123;  // 遍历函数中的所有指令  for (inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I) &#123;    // 遍历指令的所有操作数    for (User::op_iterator op = (*I).op_begin(); op != (*I).op_end(); ++op) &#123;      Value *val = *op;      // 检查操作数是否为全局变量      if (GlobalVariable *GV = dyn_cast&lt;GlobalVariable&gt;(val)) &#123;        // 检查全局变量是否符合要求（非线程局部、未编号、非DLL导入）        if (!GV-&gt;isThreadLocal() &amp;&amp; GVNumbering.count(GV) == 0 &amp;&amp;            !GV-&gt;isDLLImportDependent()) &#123;          // 为全局变量分配编号并添加到列表中          GVNumbering[GV] = GlobalVariables.size();          GlobalVariables.push_back((GlobalVariable *)val);        &#125;      &#125;    &#125;  &#125;&#125;// 创建存储全局变量地址的全局变量数组GlobalVariable* IndirectGlobalVariablePass::getIndirectGlobalVariables(Function &amp;F, ConstantInt *EncKey) &#123;  // 构造全局变量名称  std::string GVName(F.getName().str() + &quot;_IndirectGVars&quot;);  GlobalVariable *GV = F.getParent()-&gt;getNamedGlobal(GVName);    // 如果已经存在则直接返回  if (GV)    return GV;  // 为每个全局变量创建加密的地址条目  std::vector&lt;Constant *&gt; Elements;  for (auto GVar : GlobalVariables) &#123;    // 将全局变量地址强制转换为int8指针    Constant *CE = ConstantExpr::getBitCast(GVar,         llvm::PointerType::get(Type::getInt8Ty(F.getContext()),0));    // 使用密钥对地址进行加密（通过GEP实现地址偏移）    CE = ConstantExpr::getGetElementPtr(Type::getInt8Ty(F.getContext()), CE, EncKey);    Elements.push_back(CE);  &#125;  // 创建数组类型和常量数组  ArrayType *ATy = ArrayType::get(llvm::PointerType::get(Type::getInt8Ty(F.getContext()),0),                                   Elements.size());  Constant *CA = ConstantArray::get(ATy, ArrayRef&lt;Constant *&gt;(Elements));    // 创建全局变量存储全局变量地址数组  GV = new GlobalVariable(*F.getParent(), ATy, false,                         GlobalValue::LinkageTypes::PrivateLinkage, CA, GVName);  appendToCompilerUsed(*F.getParent(), &#123;GV&#125;);  return GV;&#125;\n","tags":["混淆"]},{"title":"去除某漫画软件启动广告并绕过重打包检测","url":"/post/78290ce7.html","content":"本文不构成任何技术操作指导或建议，仅供技术交流与学习参考。如发现本文内容存在可能违反法律规定的情况，请立即联系本人删除相关内容。（已对图片中出现的包名和应用名进行处理）\n观察正常打开这个apk，就能看到会有启动广告，我们可以看到启动过程的调用栈，首先启动的就是SplashActivity。那清理广告的思路就是替换程序入口。\n\n修改MainActivity.xml文件首先自然是解包（解包和解压不一样哦）\napktool d base.apk -o output\n\n接下来修改清单文件：把这个Activity统统注释掉。然后把MainActivity设置为入口：\n&lt;activity android:configChanges=&quot;screenLayout|screenSize&quot; android:exported=&quot;true&quot; android:name=&quot;com.xxxx.xxxx.MainActivity&quot; android:screenOrientation=&quot;portrait&quot; android:windowSoftInputMode=&quot;adjustPan|stateHidden&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;    &lt;/intent-filter&gt;    &lt;/activity&gt;\n接着就可以重新打包了。签名：\nkeytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore jarsigner -verbose -keystore demo.keystore base1.apk demo.keystore\n然后重新安装上，but：\n排查检测点可以看到，我们的篡改行为被识别出来了，但是好在观察到了启动过程的调用栈启动MainActivity之后跳转到了CheckDialog方法，那我们就在jadx中找到这个方法，但是审计之后，发现这只是一个很普通的日志弹窗的方法，那我们接着查看调用栈，发现有个叫signcheck的类在调用此方法，而MainActivity就是调用了这个检测类。调用栈：MainActivity-&gt;signcheck-&gt;Checkdialog既然是采用Java层方法来检测重打包，那就好办了\n绕过检测点1.frida绕过检测脚本：\nJava.perform(        function()&#123;            let SignCheck = Java.use(&quot;com.xxxx.xxxx(包名).utils.SignCheck&quot;);            SignCheck[&quot;check&quot;].overload(&#x27;android.app.Activity&#x27;).implementation = function (activity) &#123;            return true;        &#125;;    &#125;)\n\n2.修改smali定位~\\output\\smali\\com\\xxxx\\xxxx\\MainActivity.smali给它删咯，再打包。这样就行了。3.其他思路如果继续深扒，signcheck.check调用的是SignCheckUtil.check()，而SignCheckUtil.check()中有字符串b,b就是源文件的SHA1，可以想办法把这串字符改成修改过后APK哈希值\n","tags":["安卓逆向"]},{"title":"安卓逆向-抓包","url":"/post/a11b6dd3.html","content":"本文不构成任何技术操作指导或建议，仅供技术交流与学习参考。如发现本文内容存在可能违反法律规定的情况，请立即联系本人删除相关内容。（已对图片中出现的包名和应用名进行处理）\nCharles使用官网网址：https://www.charlesproxy.com网上已经有很多相关的教程了，我这里写一遍有点浪费时间。这里给几个链接：\n\n激活工具：https://down.52pojie.cn/?query=chales\n教程：https://blog.csdn.net/weixin_43612602/article/details/135287720这个教程缺少手机端的操作：下载安装好证书之后，电脑和手机连接到同一个网络，手机WIFI设置中，长按连接的网络，选择修改网络，其中代理选择手动，代理主机名是电脑的IP地址（IP并不是每次都不变的，路由器的ARP表会更新的，所以一段时间之后重新进行代理，一定要记得重新设置一下‘代理服务器主机名’这一项）\n\n端口往往是8888：可以在电脑端Charles中的Help-&gt;SSL Proxying-&gt;install charles RootCertificate on a Mobile……..然后，当开始抓包时，点击Allow即可。\n应用抓包这次的目标是一款心理治愈类APP，它有个挖胶囊的功能，但是每个账号每天只能抓5个胶囊。开始之前，可以先把本地抓包关闭了，只抓手机上的数据包：关闭Windows Proxy。然后挖个胶囊看看怎么个事：先发送一个POST请求，获取Yaoyiyao服务，服务器随机返回一个用户的info，然后APP根据info再次发送info中相关资源的GET请求，获取诸如头像，图片，音乐之类的资源，最后再获取与该info相关的评论。再看看POST请求的param怎么设计的，有哪些参数：我们照着这个请求自己实现一下POST：\nimport requests    URL=&quot;https://服务器/services/v2/xxxx/yaoYiYao&quot;  myparams = &#123;      &quot;userId&quot;:100000,      &quot;longitude&quot;:100,      &quot;latitude&quot;:50,      &quot;blindBox&quot;:0  &#125;  myheader=&#123;      &quot;Content-Length&quot;: &quot;0&quot;,      &quot;Host&quot;: &quot;服务器&quot;,      &quot;Connection&quot;: &quot;Keep-Alive&quot;,      &quot;Accept-Encoding&quot;: &quot;gzip&quot;,      &quot;User-Agent&quot;: &quot;okhttp/4.10.0&quot;  &#125;  response=requests.post(url=URL,params=myparams,headers=myheader)  print(response.text)\n这样就能获得服务了，id可以随意伪造，longitude和latitude也是可以随意伪造的。这个功能有个机制就是每个账号每天只能挖五个胶囊，我们可以设计一下，每请求5次，更改一下账号和经纬度，就能继续获取。我据此实现了一个漂流瓶功能：\nimport requests  import random  import time  import json    class Myhttp:      def __init__(self):          # 基础URL和默认参数          self.base_url = &quot;https://服务器/services/v2/xxxx/yaoYiYao&quot;          self.userId = 100000          self.longitude = 109          self.latitude = 35          self.blindBox = 0            # 通用请求头          self.headers = &#123;              &quot;Content-Length&quot;: &quot;0&quot;,              &quot;Host&quot;: &quot;服务器&quot;,              &quot;Connection&quot;: &quot;Keep-Alive&quot;,              &quot;Accept-Encoding&quot;: &quot;gzip&quot;,              &quot;User-Agent&quot;: &quot;okhttp/4.10.0&quot;          &#125;        def update_params(self):          &quot;&quot;&quot;更新请求参数（随机化）&quot;&quot;&quot;          random.seed(time.time())          temp = random.random()            # 更新参数（使用更合理的随机化逻辑）          self.userId += int(temp * 1000000)  # 随机增加用户ID          self.longitude += (temp - 0.5) * 20  # 经度随机浮动          self.latitude += (temp - 0.5) * 20  # 纬度随机浮动            # 打印当前参数（调试用）          print(f&quot;当前参数: UserID=&#123;self.userId&#125;, 经纬度=(&#123;self.longitude&#125;, &#123;self.latitude&#125;)&quot;)        def post(self):          &quot;&quot;&quot;发送POST请求（无需参数）&quot;&quot;&quot;          try:              # 构建请求参数              params = &#123;                  &quot;userId&quot;: self.userId,                  &quot;longitude&quot;: self.longitude,                  &quot;latitude&quot;: self.latitude,                  &quot;blindBox&quot;: self.blindBox              &#125;                # 发送请求              response = requests.post(self.base_url, params=params, headers=self.headers)              response.raise_for_status()  # 若状态码不是2xx，抛出异常              response_text=json.loads(response.text)              #print(response.text)                return response_text  # 返回JSON格式的响应数据            except requests.RequestException as e:              print(f&quot;请求出错: &#123;e&#125;&quot;)              exit()      def Myprint(msg):      &quot;&quot;&quot;安全地打印消息内容，处理可能的空数据情况&quot;&quot;&quot;      if msg is None or msg.get(&quot;datas&quot;) is None:          print(&quot;没有找到有效的漂流瓶数据，跳过打印&quot;)          return        xxxx_dto = msg[&quot;datas&quot;].get(&quot;xxxxDTO&quot;)      if not xxxx_dto:          print(&quot;没有找到有效的漂流瓶信息，跳过打印&quot;)          return        # 安全获取各个字段的值      xxxx_info = xxxx_dto.get(&quot;xxxxInfo&quot;, &quot;&quot;)      user = xxxx_dto.get(&quot;user&quot;, &#123;&#125;)      nickname = user.get(&quot;nickName&quot;, &quot;无名人&quot;)      city_name = xxxx_dto.get(&quot;cityName&quot;, &quot;未知地&quot;)      create_date_short = xxxx_dto.get(&quot;createDateShort&quot;, &quot;&quot;)      media_url_list = xxxx_dto.get(&quot;mediaUrlList&quot;, &quot;&quot;)        # 打印获取到的信息      print(nickname, &#x27;from&#x27;, city_name, &#x27;\\n&#x27;, xxxx_info, &#x27;\\n&#x27;, create_date_short, &#x27;\\n&#x27;, media_url_list)  # 使用示例  if __name__ == &quot;__main__&quot;:      http_client = Myhttp()        while True:          http_client.update_params()          for i in range(5):              msg=http_client.post()  # 发送请求              Myprint(msg)              time.sleep(2)  # 等待2秒              print(&quot;\\n\\n\\n\\n\\n\\n下一个漂流瓶来咯~~~~~~\\n\\n&quot;)          # 每5次请求后等待更长时间          print(&quot;===== 休息5秒 =====&quot;)          time.sleep(3)\n再加上一点页面：\n","tags":["安卓逆向"]},{"title":"安卓逆向基础篇","url":"/post/a6aa1169.html","content":"安卓系统其实安卓系统核心就是Linux系统，保持着“万物皆文件”的特性。\n一、根目录文件夹：\n根目录 (&#x2F;)：系统的最顶层目录，包含系统核心文件和目录链接。\n系统目录 (&#x2F;system)：存放系统核心文件和库。\n/system/app：系统应用的APK文件。\n/system/bin：Linux系统命令和工具。\n/system/etc：系统配置文件。\n/system/framework：系统框架库。\n/system/lib：系统共享库文件（.so）。\n/system/media：系统媒体文件，如铃声、图片等。\n\n\n数据目录 (&#x2F;data)：用户数据和应用程序数据。\n/data/app：用户安装的应用APK文件。\n/data/data/&lt;package_name&gt;：每个应用的私有数据目录。\n\n\n缓存目录 (&#x2F;cache)：临时文件和缓存数据。\n存储目录 (&#x2F;sdcard):外部存储，用户视角下的“根目录”\n设备目录 (&#x2F;dev)：设备文件。\n进程目录 (&#x2F;proc)：系统运行时信息。映射内存中的进程信息\n系统属性文件 (&#x2F;system&#x2F;build.prop)：系统属性配置。\n\n二、Android 启动过程\n\n1. 引导加载程序（Bootloader）启动：  引导加载程序通常存储在设备固件中，类似电脑的 UEFI 固件（或手机的底层引导程序），主要任务是初始化硬件（如 CPU、内存、存储），并加载操作系统内核。其关键功能是验证系统分区的完整性和签名：通过厂商公钥校验核心分区（如boot内核分区、system系统分区、vbmeta签名校验分区）头部的签名数据，确保只有官方认证的系统才能启动。  我们常说的 Bootloader 解锁，是指通过厂商允许的操作（如 Fastboot 指令）触发 Bootloader 的解锁机制，使其不再强制执行分区签名校验（部分厂商会标记 “解锁状态” 并清除校验逻辑），从而允许用户刷入第三方系统或修改系统分区。\n2.内核加载：  引导加载程序会根据预定义的配置从设备存储中加载操作系统内核。\n3.内核初始化：  一旦内核加载到内存中，引导加载程序会将控制权转交给内核。内核开始执行初始化过程，包括对硬件进行初始化、建立虚拟文件系统、创建进程和线程等。\n4.启动 init 进程：  内核初始化完成后，会启动名为init的用户空间进程。init进程是Android系统的第一个用户空间进程，它负责系统的进一步初始化和启动。init进程会读取系统配置文件（例如 init.rc），并根据其中的指令启动系统服务和应用程序。\n5.启动 Zygote 进程：  在init进程启动后，会启动名为Zygote的进程。Zygote进程是Android应用程序的孵化器，它会预加载常用的Java类和资源，以加速应用程序的启动。\n6.启动系统服务（SystemServer）：  在Zygote进程启动后，还会启动一系列系统服务，例如SurfaceFlinger、ActivityManager、PackageManager等。这些系统服务负责管理系统的各个方面，包括显示、应用程序生命周期、包管理等。\n7.启动桌面程序(Launcher)：  一旦系统服务启动完成，Android系统就处于可用状态。就会启动桌面程序，用户可以开始启动应用程序并使用设备进行各种操作了。\n\n三、Android RuntimeJVM安卓的app大多都是由Java或者Kotlin编写的，JVM就是Java程序的运行时环境，但是严格来说不算是安卓运行时。使用Java编写的代码，需要经过javac或者kotlinc编译成.class文件，最后在JVM上个运行。而JVM又可简单分为Class Loader、Runtime Data Area以及Execution Engine三个部分，Class Loader负责从.class加载和分配内存。Runtime Data负责存储数据，分为方法区、堆区、栈区、程序计数器以及本地方法栈。Execution Engine负责二进制代码的执行以及垃圾回收，其中又有Interpreter（解释器执行）和JIT（即时编译）两种执行模式，JIT会把长期执行的热点代码编译成本地机器码缓存起来，后续无需解释可直接执行。\nDalvik针对JVM还要说的是，这是一种基于栈的虚拟机，如果移动端使用这种运行时，必然会对设备的性能要求很高。因此引入基于寄存器的虚拟机——Dalvik。Dalvik虚拟机的可执行文件是.dex，可以通过.class转换得来。Dalvik同样有interpreter和JIT两种执行模式。\nART到了Android4.4，Google推出了新的Android Runtime——ART。为了缩短应用启动时长，采用了AOT（Ahead-of-time）编译方式，即在程序安装时就将dex提前编译成机器码，生成一个oat文件。但这会导致安装时间延长，占用更多的存储空间。\n四、进程创建1.整个过程涉及到多个IPC（进程间通信），主要是binder、sockert机制。\n\nbinder是安卓系统特有的跨进程通信机制，基于 C&#x2F;S 架构，主要用于系统进程和应用进程间通信\nsocket是一种是网络通信方式，多用于跨设备间进程通信，但是同样可以用本地回环地址实现本地跨进程通信。安卓系统中还有一种通信用方式得比较多吧，intent机制，又可以分为显式和隐式两种。但是它是实现的组件间通信，结合binder机制可以实现跨进程的组件通信。\n\n2.进程创建大致分为四个阶段：\n\na. 点击桌面快捷方式之后，Laucher所在进程向system_server发送请求\nb. system_server中的AMS启动Proccess.start，向Zygote发送新建进程的请求。\nc. Zygote进程在系统启动过程开始创建，经过执行ZygoteInit.main()后便进入runSelectLoop()循环体内，当收到创建新的进程请求后，Zygote进程执行ZygoteConnection.runOnce()方法，最后通过fork()创建新进程。\nd. 新建的app进程相当于Zygote的子进程，接着执行handleChildProc方法，最后调用ActivityThread.main()方法。每个阶段都有着较为复杂的函数调用，具体的源码分析移步理解Android进程创建流程\n\n3.下面这个图可以大致解释启动一个app都发生了什么：\n安卓文件结构一、APK文件基本结构我们随便找个apk解压，能看到这样的目录：\n1.assets：存放静态资源文件，如图片、视频等。这些文件不会被编译，而是直接打包到最终的程序中\n2.lib：存放.so库文件，可能会针对不同架构，在其下一级目录设计多个文件夹，如armeabi-v7a、arm64-v8a、x86\n3.META-INF：存放数字签名相关文件，包括MANIFEST.MF、CERT.SF和CERT.RSA\n\nMANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。\nCERT.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。\nCERT.RSA文件中保存了公钥、所采用的加密算法等信息。\n\n4.AndroidMainfest.xml：包含应用程序的基本信息，如包名、版本号、权限、组件等。系统根据这个文件来管理应用程序的生命周期\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- AndroidManifest.xml 是每个 Android 应用的核心配置文件，     用于声明应用的组件、权限、配置信息以及与系统的交互方式 --&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.example.myapp&quot;&gt;    &lt;!-- 声明应用兼容的 SDK 版本范围 --&gt;    &lt;uses-sdk        android:minSdkVersion=&quot;21&quot;        android:targetSdkVersion=&quot;33&quot;        android:maxSdkVersion=&quot;33&quot; /&gt;    &lt;!-- 声明应用期望的设备配置 --&gt;    &lt;uses-configuration        android:reqFiveWayNav=&quot;false&quot;        android:reqHardKeyboard=&quot;false&quot;        android:reqKeyboardType=&quot;nokeys&quot;        android:reqNavigation=&quot;nonav&quot;        android:reqTouchScreen=&quot;finger&quot; /&gt;    &lt;!-- 声明应用需要的硬件或软件特性 --&gt;    &lt;uses-feature        android:name=&quot;android.hardware.camera&quot;        android:required=&quot;true&quot; /&gt;    &lt;!-- 请求应用运行所需的权限 --&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;    &lt;!-- 自定义权限定义，用于保护应用组件 --&gt;    &lt;permission        android:name=&quot;com.example.myapp.MY_PERMISSION&quot;        android:label=&quot;string:permission_label&quot;        android:description=&quot;string:permission_desc&quot;        android:protectionLevel=&quot;normal&quot; /&gt;    &lt;!-- 权限树定义，用于组织相关权限组 --&gt;    &lt;permission-tree        android:name=&quot;com.example.myapp.permission_tree&quot;        android:label=&quot;string:permission_tree_label&quot; /&gt;    &lt;!-- 权限组定义，用于对权限进行逻辑分组 --&gt;    &lt;permission-group        android:name=&quot;com.example.myapp.permission_group&quot;        android:label=&quot;string:permission_group_label&quot;        android:description=&quot;string:permission_group_desc&quot; /&gt;    &lt;!-- 声明测试工具类，用于自动化测试 --&gt;    &lt;instrumentation        android:name=&quot;androidx.test.runner.AndroidJUnitRunner&quot;        android:targetPackage=&quot;com.example.myapp&quot; /&gt;    &lt;!-- 声明应用支持的屏幕尺寸和密度 --&gt;    &lt;supports-screens        android:resizeable=&quot;true&quot;        android:smallScreens=&quot;true&quot;        android:normalScreens=&quot;true&quot;        android:largeScreens=&quot;true&quot;        android:xlargeScreens=&quot;true&quot;        android:anyDensity=&quot;true&quot; /&gt;    &lt;!-- 应用定义标签，包含应用的全局属性和组件 --&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;!-- Activity 组件声明，用于提供用户界面 --&gt;        &lt;activity            android:name=&quot;.MainActivity&quot;            android:label=&quot;@string/app_name&quot;            android:exported=&quot;true&quot;&gt;            &lt;!-- Intent Filter 定义 Activity 可以响应的 Intent 类型 --&gt;            &lt;intent-filter&gt;                &lt;!-- 声明此 Activity 可以作为应用入口点 --&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;!-- 声明此 Activity 应显示在应用启动器中 --&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;!-- Activity 别名声明，用于为现有 Activity 提供替代入口 --&gt;        &lt;activity-alias            android:name=&quot;.MainActivityAlias&quot;            android:targetActivity=&quot;.MainActivity&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;            &lt;!-- 元数据定义，用于存储额外配置信息 --&gt;            &lt;meta-data                android:name=&quot;additional_info&quot;                android:value=&quot;alias_info&quot; /&gt;        &lt;/activity-alias&gt;        &lt;!-- Service 组件声明，用于在后台执行操作 --&gt;        &lt;service            android:name=&quot;.MyService&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;false&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;com.example.myapp.MY_SERVICE&quot; /&gt;            &lt;/intent-filter&gt;            &lt;meta-data                android:name=&quot;service_config&quot;                android:value=&quot;config_value&quot; /&gt;        &lt;/service&gt;        &lt;!-- BroadcastReceiver 组件声明，用于监听系统或应用事件 --&gt;        &lt;receiver            android:name=&quot;.MyReceiver&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;            &lt;/intent-filter&gt;            &lt;meta-data                android:name=&quot;receiver_data&quot;                android:value=&quot;data_value&quot; /&gt;        &lt;/receiver&gt;        &lt;!-- ContentProvider 组件声明，用于跨应用共享数据 --&gt;        &lt;provider            android:name=&quot;.MyContentProvider&quot;            android:authorities=&quot;com.example.myapp.provider&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;false&quot;&gt;            &lt;!-- 声明允许访问的 URI 权限 --&gt;            &lt;grant-uri-permission                android:path=&quot;/data&quot;                android:pathPattern=&quot;/.*&quot;                android:pathPrefix=&quot;/images&quot; /&gt;            &lt;meta-data                android:name=&quot;provider_info&quot;                android:value=&quot;provider_value&quot; /&gt;        &lt;/provider&gt;        &lt;!-- 声明应用需要链接的共享库 --&gt;        &lt;uses-library            android:name=&quot;android.test.runner&quot;            android:required=&quot;true&quot; /&gt;    &lt;/application&gt;&lt;/manifest&gt;\n5.classes.dex：包含应用程序的所有Java类和方法，是应用程序的可执行文件。它是一个被编译过的DEX（Dalvik Executable）文件，用于在Android设备上运行Java代码，通常不止一个。\n6.resources.arsc：包含应用程序的所有资源信息，如布局文件、字符串、图片等。这个文件在应用程序编译过程中由aapt工具生成，并被打包进APK文件中\n二、ELF文件格式ELF是unix系统的二进制文件。前面说过安卓是基于Linux内核，如 init（系统初始化进程）、zygote（安卓应用孵化器）都是ELF文件，APP的动态链接库也是ELF文件。\nELF Header:描述了描述了体系结构和操作系统等基本信息并指出Section Header Table和Program Header Table在文件中的什么位置Program Header Table: 保存了所有Segment的描述信息Section Header Table:保存了所有Section的描述信息\n常见字段含义：\nGOT\n全称：Global Offset Table（全局偏移表）。\n位置：数据段（.got&#x2F;.got.plt）。\n作用：存储全局变量和外部函数的地址，运行时可被动态链接器修改。\n\nPLT\n全称：Procedure Linkage Table（程序链接表）。\n位置：代码段（.plt）。\n作用：包含汇编指令，实现外部函数的延迟绑定和调用跳转。\n特性：程序加载后不可修改（只读），但可通过 GOT 间接控制跳转目标。\n\n重定位重定位（Relocation）是计算机程序链接和加载过程中的关键机制，用于解决程序中符号（如函数、变量）地址的动态分配问题。简单来说，它是将程序中符号的逻辑地址转换为实际物理地址**的过程。那么在Linux系统中，重定位的过程实际就是通过GOT表和PLT表来实现的。可以分为两个阶段：\n\n链接重定位：也叫静态重定位。在链接阶段，当发现函数是外部函数时，链接器在PLT段生成一段跳转代码PLT Stub,然后将代码中调用该函数的地址换成stub的地址\n运行时重定位：也叫动态重定位。在运行时，把外部函数的地址加载到got表中，调用该函数时，通过plt调转到got表中存储的地址实现调用。\n\n延迟绑定延迟绑定指的是将外部函数地址的解析推迟到首次调用时，从而减少程序启动时间。程序启动时，仅初始化 PLT（程序链接表）和 GOT（全局偏移表）的结构，不立即解析函数地址。静态重定位是在给延迟绑定做准备，动态重定位是在执行阶段。与延迟绑定对应的是立即绑定。 动态链接器遍历所有外部符号（如printf、malloc)。 一次性解析所有符号的真实地址，并更新 GOT 表。 直接通过 GOT 表中的真实地址调用，无需动态链接器介入。\n参考文档Android目录结构全解析Android启动流程理解Android进程创建流程深入理解Android-RuntimeAndroidManifest.xml 最全详解Android Hook技术学习——常见的Hook技术方案总结\n","tags":["安卓逆向"]},{"title":"某款三国类题材游戏绕过Frida检测尝试","url":"/post/cd471d9e.html","content":"本文不构成任何技术操作指导或建议，仅供技术交流与学习参考。如发现本文内容存在可能违反法律规定的情况，请立即联系本人删除相关内容。（已对图片中出现的包名和应用名进行处理）\n学习一篇文章：SO加载参考文档：bilibili frida检测分析绕过\n1.绕过frida反调试学习到在linux系统中，so的加载是dlopen函数(系统级)在处理，frida检测往往在SO文件中，那我们就要排查是哪个SO文件在做这个事情，即查看调用栈。可以通过hook这个函数来查看调用栈：\n\tfunction hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;        onEnter: function(args) &#123;            var pathptr = args[0];            if (pathptr) &#123;                var path = ptr(pathptr).readCString();                console.log(&quot;Loading: &quot; + path);                if (path.indexOf(soName) &gt;= 0) &#123;                    console.log(&quot;Already loading: &quot; + soName);                    // hook_system_property_get();                &#125;            &#125;        &#125;    &#125;);&#125;setImmediate(hook_dlopen);\n结果如下：\n[ONEPLUS A6010::com.xxxxxxxxxx ]-&gt; Loading: /system/framework/oat/arm64/embryo.odexLoading: /system/framework/oat/arm64/org.apache.http.legacy.boot.odexLoading: /data/app/com.xxxxxxxxxx-YbqwF-6pNu60XJkbEOJhjg==/oat/arm64/base.odexLoading: /data/app/com.xxxxxxxxxx-YbqwF-6pNu60XJkbEOJhjg==/lib/arm64/libnicai.soLoading: /data/app/com.xxxxxxxxxx-YbqwF-6pNu60XJkbEOJhjg==/lib/arm64/libmsaoaidsec.soAlready loading: libmsaoaidsec.soProcess terminated[ONEPLUS A6010::com.xxxxxxxxxx ]-&gt;\n\nfrida检测点就应该在libmsaoaidsec.so中，继续缩小范围，从下面这张图，我们可以了解到，在加载so时，在jni_onload()函数之前会先加载init()函数，我们可以通过设置jni钩子来判断检测点处在哪个阶段。代码如下：\nfunction hook_JNI_OnLoad()&#123;    let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.attach(module.base.add(0x13a4c + 1), &#123;        onEnter(args)&#123;            console.log(&quot;JNI_OnLoad&quot;)        &#125;    &#125;)&#125;\nhook后，没有任何回显，frida被毙掉，那么监测点就在init函数后，jni函数前。搜索：定位.init_proc函数，但是发现有平坦化混淆：通过D810去混淆结果如下：\nvoid init_proc()&#123;  const char *v0; // x23  __int64 v1; // x0  unsigned int v2; // w0  unsigned __int64 StatusReg; // [xsp+0h] [xbp-870h] BYREF  void *v4; // [xsp+8h] [xbp-868h]  int v6; // [xsp+18h] [xbp-858h]  int v7; // [xsp+1Ch] [xbp-854h]  void *v8; // [xsp+20h] [xbp-850h]  char *v10; // [xsp+30h] [xbp-840h]  FILE *v11; // [xsp+38h] [xbp-838h]  char v12[2000]; // [xsp+40h] [xbp-830h] BYREF  __int64 v13; // [xsp+810h] [xbp-60h]  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 0xD, 0, 2));  v13 = *(StatusReg + 40);  v4 = &amp;StatusReg + -0xFA;  *off_47FB8 = sub_123F0();  sub_12550();  sub_12440();  if ( *off_47FB8 &gt; 23 )    *off_47ED8 = 1;  if ( (sub_25A48() &amp; 1) == 0 )  &#123;    v10 = v12;    memset(v10, 0, 0x7D0uLL);    v2 = getpid();    _sprintf_chk(v12, 0LL, 2000LL, &quot;/proc/%d/cmdline&quot;, v2);    v11 = fopen(v12, &quot;r&quot;);    if ( v11 )    &#123;      v8 = v4;      memset(v4, 0, 0x7D0uLL);      v0 = v4;      fscanf(v11, &quot;%s&quot;, v4);      fclose(v11);      if ( !strchr(v0, 58) )        sub_1BEC4();    &#125;    v1 = sub_13728();    sub_23AD4(v1);    v6 = sub_C830();    if ( v6 != 1 || (v7 = sub_95C8()) != 0 )      sub_9150();  &#125;&#125;\n主要是绕过if ( (sub_25A48() &amp; 1) == 0 )分支，加上这段被混淆了，要善用Graph，下面框中的代码块就是需要绕过的逻辑修改调度器函数如下：然后apply patch，重打包app，安装到手机上，看看效果：耶！成功！！！\n","tags":["安卓逆向"]},{"title":"熊猫烧香病毒分析（上）","url":"/post/1f2365ca.html","content":"准备样本信息：\n文件名：xiongmao.txt\nMD5：512301c535c88255c9a252fdf70b7a03\nSHA256:40fee2a4be91d9d46cc133328ed41a3bdf9099be5084efbc95c8d0535ecee496\n大小：30,001 字节\n实验环境与工具：虚拟环境：windows_7_ultimate_with_sp1_x86\n工具：IDA_Pro、x64dbg、PCHunter、HRSword、DIE_win32   （由于HRSword进程总是被病毒干掉，得结合着PCHunter和录屏来看）\n行为分析tips:由于是在win7系统中进行的行为分析，我们需要使用以管理员身份运行。在win xp系统中，默认用户拥有管理员权限，无需授权的执行就可以修改系统文件，这也就给计算机病毒提供了温床。\n1.启动资源管理器发生闪退病毒成功运行。\n2.复制到drivers路径下：\n并创建相关启动项\n\n\n3.程序的exe文件被“感染”\n4.创建大量Desktop.ini文件几乎每个路径下都有，只写入了创建时间。\n\n\n5.在C盘根目录下创建setup.exe和autorun.inf\n两个文件有隐藏属性\n\n病毒作者意图是访问c盘或插入U盘时，自动启动setup文件，但这个样的设计已经在win7即更高版本的Windows系统中失效。\n- Windows 7 及更新系统默认禁用 U盘移动硬盘的 autorun.inf 自动运行功能（仅保留光驱支持）。- 需手动打开设备或触发右键菜单才会执行程序。\n\n6.网络方面\n\nSYN_SENT 状态（端口139）： 大量向不同内网IP的139端口发起连接请求，表明内网扫描行为，用于探测漏洞或横向传播恶意软件（如利用SMB协议漏洞）。\nESTABLISHED 状态（端口80）： 成功连接至192.168.42.1:80，可能意图是恶意软件与C2服务器通信或数据外传\n\n二进制文件分析：查壳与脱壳：查壳：是有壳的。FSG工具打包\n\n简单说一下怎么脱，上面的DIE被扰乱了，实际只有FSG壳，这个样本同时具有FSG壳OEP特征和DelPhi编译器入口特点，很好找OEP，scylla普通模式找IAT表，然后dump+fix dump，就可以了。\n\n\n\n能看到还是恢复了很多东西。\n逆向伪代码分析：\n\nj_XXXXX是识别出来的系统函数名\nC_XXXX是分析过后的自定义的，逻辑分析得比较清晰可信的函数名\nM_XXXX是未细致分析过的自定义的，根据上下文初步猜测的函数名\nsub_XXXX则是IDA根据函数偏移命名的函数名\n\n动态调试分析：通过调试结果，观察运行后变量表现，推测函数功能\n执行前：（C_GetAbsolutePath）\n\n执行后：\n\n\n参数在函数执行前后的变化很明显，获得该程序的绝对路径。\n静态分析：通过对已确认函数名的调用，分析该函数的功能：\n\n通过j_GetCommandLineA和j_GetModuleFileNameA可以分析出sub_40277c与获取路径相关。\n分析结果：C_mian（部分）:\nC_GetParentCatalogue：\n未完待续~~~","tags":["病毒分析"]},{"title":"熊猫烧香病毒分析（下）","url":"/post/a79f02af.html","content":"最后进行病毒专杀和文件修复的工作。\n病毒专杀：由于现流行的编程语言版本和编译器版本编写专杀工具需要解决兼容win7_x32的问题，我就不花心思去解决了。我们可以使用批处理文件来实现。\n程序需要实现的功能：\n\n \n删除并结束spo0lsv进程\n\n \n遍历每个盘，找到并删除setup.exe和autorun.inf，要避免误杀同名文件。\n\n \n遍历路径，查找并删除Desktop_.ini,同样要避免误杀同名文件。\n\n \n修改注册表，删除Software\\Microsoft\\Windows\\CurrentVersion\\Run\\svcshare和SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\Hidden\\SHOWALL\\CheckedValue\n\n\n批处理文件实现：@echo offsetlocal enabledelayedexpansionREM 提升为管理员权限（需保存为.bat运行）NET FILE &gt;NUL 2&gt;&amp;1 || (powershell -Command &quot;Start-Process &#x27;%~f0&#x27; -Verb RunAs&quot; &amp; exit b)REM ██████ 终止进程并删除驱动文件 ██████taskkill F IM spo0lsv.exe &gt;nul 2&gt;&amp;1if exist &quot;C:\\windows\\System32\\drivers\\spo0lsv.exe&quot; (    attrib -H -S &quot;C:\\windows\\System32\\drivers\\spo0lsv.exe&quot; &gt;nul 2&gt;&amp;1    del F Q &quot;C:\\windows\\System32\\drivers\\spo0lsv.exe&quot; &gt;nul 2&gt;&amp;1    echo 已删除 spo0lsv.exe)REM ██████ 遍历所有盘符删除隐藏的病毒文件 ██████for f &quot;skip=1&quot; %%d in (&#x27;wmic logicaldisk where &quot;DriveType=2 OR DriveType=3&quot; get name&#x27;) do (    set &quot;drive=%%d&quot;    if defined drive (        echo 深度扫描盘符: !drive!                REM ─── 处理根目录隐藏文件 ───        for %%f in (&quot;!drive!\\setup.exe&quot; &quot;!drive!\\autorun.inf&quot;) do (            if exist %%f (                attrib -H -S -A %%f &gt;nul 2&gt;&amp;1                del F Q %%f &gt;nul 2&gt;&amp;1                echo 已清除根目录隐藏文件: %%f            )        )                REM ─── 递归处理子目录（含隐藏文件）───        for f &quot;delims=&quot; %%f in (&#x27;dir !drive!\\* s b a:-d a:h 2^&gt;nul ^| findstr i &quot;\\\\setup.exe$ \\\\autorun.inf$&quot;&#x27;) do (            set &quot;filepath=%%f&quot;            REM 排除系统关键路径            if not &quot;!filepath:\\Windows\\=!&quot;==&quot;!filepath!&quot; (                echo 跳过系统文件: %%f            ) else if not &quot;!filepath:\\Program Files\\=!&quot;==&quot;!filepath!&quot; (                echo 跳过程序文件: %%f            ) else (                attrib -H -S &quot;%%f&quot; &gt;nul 2&gt;&amp;1                del F Q &quot;%%f&quot; &gt;nul 2&gt;&amp;1                echo 已删除隐藏病毒文件: %%f            )        )    )):: 全盘遍历所有Desktop_.ini（严格匹配带下划线的文件名）set &quot;drive=C:&quot;REM 递归搜索并强制删除所有隐藏的Desktop_.ini文件for f &quot;delims=&quot; %%f in (&#x27;dir a:h s b &quot;%drive%\\Desktop_.ini&quot;&#x27;) do (    del F Q A:H &quot;%%f&quot; &gt;nul 2&gt;&amp;1    if exist &quot;%%f&quot; (        echo 删除失败（可能被占用或权限不足）: %%f    ) else (        echo 已删除: %%f    ))REM ██████ 注册表修复 ██████reg delete &quot;HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\svcshare&quot; f &gt;nul 2&gt;&amp;1reg delete &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\Hidden\\SHOWALL\\CheckedValue&quot; f &gt;nul 2&gt;&amp;1echo 注册表修复完成pause\n\n文件恢复：逆向感染代码：我们重新关注C_InfectFile(sub_407F00):\n\n大致逻辑：\n\n是把自己复制到目标文件目录下，伪装成目标文件（直接覆盖目标文件）\n\n把目标文件附加到伪装文件之后\n\n再在伪装文件之后添加一段字符串（”WhBoy”+”原文件名”+“.exe”+02+“原文件字节数”+01）\n\n这就实现了病毒“感染”。\n\n\n编程文件恢复：流程如下：\n\n 识别被感染的病毒——可以通过末尾字符串识别。\n 删除病毒部分——删除文件前30001个字节，这个部分应该建议通过计算原病毒大小来动态处理。\n 删除文件最后的字符串标识。\n\n批处理文件实现：代码如下：\n::C:\\Program Files\\IDA 6.8\\idaw64.exe@echo offsetlocal enabledelayedexpansion:: 必须用管理员运行（右键选&quot;以管理员身份运行&quot;）set &quot;target_file=文件路径&quot;:: 阶段1：安全截断前30001字节powershell -Command &quot;$f=&#x27;%target_file%&#x27;; if (Test-Path $f) &#123; $b=[IO.File]::ReadAllBytes($f); [IO.File]::WriteAllBytes($f, $b[30001..($b.Length-1)]) &#125; else &#123; exit 1 &#125;&quot;:: 阶段2：精准解析尾部标识符powershell -Command &quot;$f=&#x27;%target_file%&#x27;; $bytes=[IO.File]::ReadAllBytes($f); $sepIndex=$bytes.Length-1; while($sepIndex -ge 0 -and $bytes[$sepIndex] -ne 2)&#123;$sepIndex--&#125;; $numStr=-join[char[]]$bytes[($sepIndex+1)..($bytes.Length-1)] -replace &#x27;[^0-9]&#x27;,&#x27;&#x27;; [IO.File]::WriteAllBytes($f, $bytes[0..([int]$numStr-1)]); echo 修复成功，最终大小: $numStr 字节&quot;pause\n\n\n心得：  这个病毒总的分析下来学到很多东西，编写者具有很强的工程思维，逻辑缜密，代码功力也很强。\n最后：\n\n\n太恐怖了，一觉醒来，就要攻击宿主机了。虚拟机网络还是设置成hostonly模式，并且宿主机关闭该局域网的”Internet 协议版本4（TCPIPv4）”才是安全的。\n","tags":["病毒分析"]},{"title":"熊猫烧香病毒分析（中）","url":"/post/22c6f24d.html","content":"\nsub_40819C:预备阶段实现对原病毒所在路径下的desktop.ini文件的删除和将自己复制到drivers路径下并启动\nv55 &#x3D; __readfsdword(0)sub_40819C函数开头的 v55 &#x3D; __readfsdword(0)可以反编译成\nExceptionList = NtCurrentTeb()-&gt;NtTib.ExceptionList;\n\n和\n__writefsdword(0, &amp;v55);\n\n一起处理异常。\n查找Desktop_.ini并删除：检测是否存在该文件，若存在，先修改其属性为隐藏，再进行删除。\n\n这段代码并不是我们之前观察到的创建Desktop_.ini文件实现代码。\n自我复制到C:windowsSystem32drivers路径下：先检测是否已经存在该进程和文件，有就先kill该进程和修改属性，再获取System32路径，拼接路径，自我复制到驱动目录下再运行，最后退出当前进程。\n\nsub_407B68（）：自毁程序:try1del &quot;原程序.exe&quot;      → 尝试删除被锁定的程序文件if exist &quot;原程序.exe&quot; goto try1 → 循环检测直到进程退出ren &quot;原程序.exe&quot; 临时名称 → 解除文件锁定后重命名del 临时名称          → 删除重命名后的文件del %0               → 最后删除批处理自己\n\n当程序自然退出后，批处理文件将会开始执行。\nsub_40D18C:爆发阶段实现对各目录下Desktop_.ini文件的创建，对其余文件的感染，和setup.exe文件的创建，以及实现内网横向渗透\nsub_0040A5B0:创建线程执行：sub_40A48C：\n\n来执行遍历路径，创建Desktop_.ini文件和感染可执行文件的逻辑（读取系统时间并写入）：\n\n感染可执行文件相关：\n\nC_InfectFile：\n\nsub_40C374：设置一个6s的计时器运行TimerFunc函数，TimerFunc核心逻辑就是在系统盘创建setup.exe和相应的自启动文件autorun.inf。\nsub_40BACC： 创建线程，执行网络连接，实现横向内网渗透，通过SMB协议扫描：\nSystem::BeginThread(sub_40BA8C, 0, 0, &amp;v6, 0, 0, v3); 多线程运行,横向内网渗透，\n\nsub_40D088:对抗安全查杀恶意下载与执行相关，对抗安全软件和监控\n设置了6个计时器：\n\n\n\n定时器地址\n时间间隔\n回调函数\n功能描述\n\n\n\n0x3E8u\n1秒\nsub_40CEE4\n创建自启动项 (spo0lsv)，实现持久化\n\n\n0x124F80u\n20分钟\nsub_40D040\n核心恶意下载模块（可能下载远控木马或勒索组件）\n\n\n0x2710u\n10秒\nsub_40D048\n下载后抹除痕迹（删除日志、加密通信等）\n\n\n0x1770u\n6秒\nsub_407430\n系统性终止安全软件服务，删除注册表启动项（针对性对抗杀软）\n\n\n0x2710u\n10秒\nsub_40CC4C\n隐蔽数据下载（可能用于泄露敏感信息或接收指令）\n\n\n0x1B7740u\n30分钟\nsub_40C728\n二次恶意下载（更新组件或下载额外攻击载荷）\n\n\n特别是在sub_40CEE4函数中的sub_406E2C函数：\n执行sub_4061B8，实现通过关闭安全软件窗口、终止关键进程、模拟用户操作，破坏系统防御能力，确保恶意程序持续运行：\n\n最后把分析的思维图放到最后：\n\n","tags":["病毒分析"]},{"title":"第一次刷入aosp记录","url":"/post/dc3d4965.html","content":"1.问题描述：在刷入基础镜像后会重新启动并进入fastbootd模式，但是卡在Google的logo处，无法进入fastbootd。回答：这应该是驱动对不上，要在https://developers.google.com/android/drivers通过版本号找到对应驱动\n2、问题描述：确保驱动和系统版本对齐之后，刷入系统却卡在fastboot模式回答：需要更新fastboot工具\n3、问题描述：成功刷机，进入系统，但是屏幕触控失效，触控驱动 &#x2F; I2C 设备通信失败。10-03 09:04:23.946     0     0 I         : c3   1246 bad ioctl: -1072934383回答：wsl编译android内核并刷入pixel4 - 怎么可以吃突突 - 博客园有解决办法修改点：1、注释掉/home/towertan/AOSP_SRC/android-kernel-pixel4/private/msm-google/kernel/module.c中check_modinfo函数返回失败值2、增删/home/towertan/AOSP_SRC/android-kernel-pixel4/private/msm-google/arch/arm64/configs/floral.defconfig,增加CONFIG_TOUCHSCREEN_FTS=y，删除CONFIG_MODVERSIONS=y3、修改/home/towertan/AOSP_SRC/android-kernel-pixel4/private/msm-google\\build.config.floral_no-cfi,注释掉POST_DEFCONFIG_CMDS=&quot;check_defconfig &amp;&amp; update_nocfi_config&quot;\n后续：重新编译系统，这次不使用自己编译的内核，使用代码树上编译行的boot.img，查看之后\n4、内核增量编译：利用aosp项目中自带的工具：unpack_bootimg.py、mkbootimg.py\n#解压boot.img&gt;&gt;&gt;towertan@towertan-vm:~/AOSP_SRC/boot_unpack$ python3 ~/AOSP_SRC/aosp13_7r/system/tools/mkbootimg/unpack_bootimg.py --boot_img boot.imgboot magic: ANDROID!kernel_size: 20810890kernel load address: 0x00008000ramdisk size: 16932208ramdisk load address: 0x01000000second bootloader size: 0second bootloader load address: 0x00000000kernel tags load address: 0x00000100page size: 4096os version: 13.0.0os patch level: 2022-10boot image header version: 2product name: command line args: console=ttyMSM0,115200n8 androidboot.console=ttyMSM0 printk.devkmsg=on msm_rtb.filter=0x237 ehci-hcd.park=3 service_locator.enable=1 androidboot.memcg=1 cgroup.memory=nokmem usbcore.autosuspend=7 androidboot.usbcontroller=a600000.dwc3 swiotlb=2048 androidboot.boot_devices=soc/1d84000.ufshc loop.max_part=7 buildvariant=userdebugadditional command line args: recovery dtbo size: 0recovery dtbo offset: 0x0000000000000000boot header size: 1660dtb size: 1048284dtb address: 0x0000000001f00000&gt;&gt;&gt;towertan@towertan-vm:~/AOSP_SRC/boot_unpack$ cd out#替换其中的kernel文件&gt;&gt;&gt;towertan@towertan-vm:~/AOSP_SRC/boot_unpack/out$ cp ~/AOSP_SRC/android-kernel-pixel4/out/android-msm-pixel-4.14/dist/Image.lz4 ./kernel#根据前面解压分析出的参数重新制作镜像&gt;&gt;&gt;towertan@towertan-vm:~/AOSP_SRC/boot_unpack/out$ python3 ~/AOSP_SRC/aosp13_7r/system/tools/mkbootimg/mkbootimg.py \\  --kernel ./kernel \\  --ramdisk ./ramdisk \\  --dtb ./dtb \\  --cmdline &quot;console=ttyMSM0,115200n8 androidboot.console=ttyMSM0 printk.devkmsg=on msm_rtb.filter=0x237 ehci-hcd.park=3 service_locator.enable=1 androidboot.memcg=1 cgroup.memory=nokmem usbcore.autosuspend=7 androidboot.usbcontroller=a600000.dwc3 swiotlb=2048 androidboot.boot_devices=soc/1d84000.ufshc loop.max_part=7 buildvariant=userdebug&quot; \\  --base 0x00000000 \\  --kernel_offset 0x00008000 \\  --ramdisk_offset 0x01000000 \\  --tags_offset 0x00000100 \\  --pagesize 4096 \\  --header_version 2 \\  --os_version 13.0.0 \\  --os_patch_level 2022-10 \\  -o ../new_boot.img&gt;&gt;&gt;towertan@towertan-vm:~/AOSP_SRC/boot_unpack/out$ ls ../boot.img  new_boot.img  out\n\n5、uname -a得到的提交分支显示dirty（这应该是承接的问题3）:应该是问题三中，采用了修改module.c的方法来修复触屏失效问题产生的次生问题，对于安卓13，更换驱动可能还是要从镜像下手……..\n","tags":["刷机&改机"]},{"title":"记第一次Hook（Frida）和Apktool修改安卓程序","url":"/post/fd83d09f.html","content":"1.apltool基础操作：安卓apk反编译、修改、重新打包、签名全过程 - cnkker.com - 博客园\n2.Frida靶场：Frida练习靶场(上篇) - FreeBuf网络安全行业门户\n需要注意的是，在使用apktool时，文件路径不能有空格\nHook使用的是Frida靶场的第一个题：\n\n将输入与随机数做比较，匹配上就能得到flag，虽然说在CTF比赛中我们通常采用直接分析加密过程来解密，但是如果能熟练使用Hook，应该会更快一些。1.我选择Hook get_random函数，可以Hook生成数，也可以覆盖为自定义数选中函数，右键可以直接复制为Frida片段：\nlet MainActivity = Java.use(&quot;com.ad2001.frida0x1.MainActivity&quot;);MainActivity[&quot;get_random&quot;].implementation = function () &#123;    console.log(`MainActivity.get_random is called`);    let result = this[&quot;get_random&quot;]();    console.log(`MainActivity.get_random result=$&#123;result&#125;`);    return result;&#125;;\n套上:Java.perform(function(){    frida片段});在命令行使用frida -U -f 包名 -l test.js 就可以Hook上。\napktool篡改：已经下好了apktool并写入了环境变量\n反编译指令：\napktool d xxx.apk -o output_dir\n编译指令：\napktool b output_dir -o test.apk\n签名：生成keystore文件(java环境自带keytool)：\nkeytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore\n签名apk：\njarsigner -verbose -keystore demo.keystore test.apk demo.keystore\n\n篡改smali：源文件：\n\n可以修改返回值：修改返回值为0x1,即只要输入6就一定正确。\n","tags":["安卓逆向"]},{"title":"除水印小程序逆向分析","url":"/post/1ebbdde9.html","content":"​        大家都能发现，现在的手机应用隔三差五就要更新，存储空间的需求还越来越大，而各类平台的小程序凭借着面相用户轻量便捷，面相平台丰富生态的作用越来越受到市场的追捧。小程序介于网页端和应用端，同时具备了两者的优点，甚至有些厂商渐渐砍掉应用的研发，转而开发和维护小程序端口。但是目前的小程序安全却是良莠不齐，有的层层加固，有的直接裸奔。\n​       本文记录了对一个去除视频水印小程序的逆向过程：\n解密与解包：我们使用wedecode这个开源项目进行解密和解包。\n加密工具使用时，如果小程序包已从原Applet地址移出，也应当保留小程序包上两级的路径，如： ~\\Applet\\wx1680cca9a19ee3c8\\48\\__APP__.wxapkg&quot;。“wx1680cca9a19ee3c8”这一字符串应当保留，与解密有关（采用的AES加密，这个字符串与秘钥生成有关，后面比对发现，这个字符串同时也是APPID。）\n然后使用wedecode解包后，使用微信开发者程序打开调试。可能因为文件解包的问题，或多或少都会遇到几个文件语法格式的问题：\n\n我们得根据提示一个一个修正：\n\n app.json: componentFramework 字段需为 exparser,glass-easel componentFramework 字段需为 string\n\n&quot;componentFramework&quot;: &#123;  &quot;allUsed&quot;: [    &quot;exparser&quot;  ],  &quot;default&quot;: &quot;exparser&quot;&#125;,\n\n修改为：\n&quot;componentFramework&quot;:&quot;exparser&quot;,\n\n\n \napp.json: [“tabBar”][“list”][0][“iconPath”] should not contain \\\n把全部的“\\\\”替换成“&#x2F;”,\n\n\n重新编译之后就可以运行：\n分析核心功能：定位index.js中的query方法。\nquery: function(e) &#123;  var a = this,    n = a.isUrl(a.data.inputvalue);  n &amp;&amp; wx.showLoading(&#123;    title: &quot;正在解析&quot;  &#125;) &amp;&amp; (wx.request(&#123;    url: t.globalData.url + &quot;query&quot;,请求体    data: &#123;      url: n,      token: wx.getStorageSync(&quot;token&quot;),      id: wx.getStorageSync(&quot;id&quot;),      user_id: t.globalData.user_id    &#125;,    success: function(t) &#123;      wx.hideLoading(), 104 == t.data.code ? wx.showModal(&#123;        title: &quot;提示：&quot;,        content: t.data.message,        confirmColor: &quot;#ff9900&quot;,        showCancel: !1,        success: function(t) &#123;&#125;      &#125;) : (wx.hideLoading(), a.setLog(a.data.inputvalue), 3 != t.data.data.type ? a.setData(&#123;        title: t.data.data.title,        photo: t.data.data.photo,        downurl: t.data.data.downurl,        url2: t.data.data.url2 ? t.data.data.url2 : 0,        pics: t.data.data.pics      &#125;) : (wx.setStorageSync(&quot;picsaa&quot;, t.data.data), wx.navigateTo(&#123;        url: &quot;pagespicshhindex&quot;      &#125;)))    &#125;  &#125;), setTimeout((function() &#123;    o &amp;&amp; a.data.ad_chaping &amp;&amp; o.show().catch((function(t) &#123;      console.error(t)    &#125;))  &#125;), 2e3))&#125;,\n\n在app.js中找到globalData对象：\n  .........  globalData: &#123;    url: &quot;https:qq.yyymvp.com&quot;,    user_id: 8  &#125;&#125;);\n\n从业务代码可知，请求体是：\nwx.request(&#123;      url: t.globalData.url + &quot;query&quot;,请求体      data: &#123;        url: n,        token: wx.getStorageSync(&quot;token&quot;),        id: wx.getStorageSync(&quot;id&quot;),        user_id: t.globalData.user_id      &#125;,\n\n可以看到它的安全性确实太低了，token和id都是不验证的，userid就是硬编码的。那么这个工具的小程序后台我们就可以直接使用了，避免烦人的广告。\n简易代码如下：\nimport requestsUrl=&quot;https:qq.yyymvp.com&quot;o_url= &quot;https:example&quot;user_id=8token=&#x27;&#x27;id_=&#x27;&#x27;data=&#123;    &quot;url&quot;:o_url,    &quot;token&quot;:token,    &quot;id&quot;:id_,    &quot;user_id&quot;:8&#125;res=requests.post(    Url+&quot;query&quot;,    data=data,)res_text=res.json()print(res_text[&#x27;data&#x27;][&#x27;downurl&#x27;])\n\n我们可以把它部署在自己的电脑上，或者编写一个短小的程序，供自己使用。\n 除水印小程序.py \n","tags":["小程序逆向"]},{"title":"雷电模拟器&IDA动调.so文件","url":"/post/android.html","content":"前提：雷电模拟器开启root权限，模拟器设置中开启开发者模式&amp;&amp;USB调试\n\nadb push ../../../../android_x64_server \\data\\local\\tmpadb forward tcp:23946 tcp:23946adb shellsucd data/local/tmpchmod 777 android_x64_server./android_x64_server      #在进入adb shell 之前，可以先获得临时root身份（adb root），进入shell之后再获得超级管理员权限(su)\n\n虚拟机中运行apk，用ida打开.so文件：\n\n1.IDA打开so文件，定位到待分析函数并下断点：【New】【Export或Function window搜索函数双击定位】\n\n2.附加程序，进入动态调试界面：【Debugger—&gt;Process options】【Hostname:127.0.0.1 Port:23946】然后【Debugger—&gt;Attach to Process】\n\n\n\n找到自己想要的进程，attach.\n","tags":["安卓逆向"]}]