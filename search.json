[{"title":"某款三国类题材游戏绕过Frida检测尝试","url":"/post/cd471d9e.html","content":"本文不构成任何技术操作指导或建议，仅供技术交流与学习参考。如发现本文内容存在可能违反法律规定的情况，请立即联系本人删除相关内容。（已对图片中出现的包名和应用名进行处理）\n学习一篇文章：SO加载参考文档：bilibili frida检测分析绕过\n1.绕过frida反调试学习到在linux系统中，so的加载是dlopen函数(系统级)在处理，frida检测往往在SO文件中，那我们就要排查是哪个SO文件在做这个事情，即查看调用栈。可以通过hook这个函数来查看调用栈：\n\tfunction hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;        onEnter: function(args) &#123;            var pathptr = args[0];            if (pathptr) &#123;                var path = ptr(pathptr).readCString();                console.log(&quot;Loading: &quot; + path);                if (path.indexOf(soName) &gt;= 0) &#123;                    console.log(&quot;Already loading: &quot; + soName);                    // hook_system_property_get();                &#125;            &#125;        &#125;    &#125;);&#125;setImmediate(hook_dlopen);\n结果如下：\n[ONEPLUS A6010::com.xxxxxxxxxx ]-&gt; Loading: /system/framework/oat/arm64/embryo.odexLoading: /system/framework/oat/arm64/org.apache.http.legacy.boot.odexLoading: /data/app/com.xxxxxxxxxx-YbqwF-6pNu60XJkbEOJhjg==/oat/arm64/base.odexLoading: /data/app/com.xxxxxxxxxx-YbqwF-6pNu60XJkbEOJhjg==/lib/arm64/libnicai.soLoading: /data/app/com.xxxxxxxxxx-YbqwF-6pNu60XJkbEOJhjg==/lib/arm64/libmsaoaidsec.soAlready loading: libmsaoaidsec.soProcess terminated[ONEPLUS A6010::com.xxxxxxxxxx ]-&gt;\n\nfrida检测点就应该在libmsaoaidsec.so中，继续缩小范围，从下面这张图，我们可以了解到，在加载so时，在jni_onload()函数之前会先加载init()函数，我们可以通过设置jni钩子来判断检测点处在哪个阶段。代码如下：\nfunction hook_JNI_OnLoad()&#123;    let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.attach(module.base.add(0x13a4c + 1), &#123;        onEnter(args)&#123;            console.log(&quot;JNI_OnLoad&quot;)        &#125;    &#125;)&#125;\nhook后，没有任何回显，frida被毙掉，那么监测点就在init函数后，jni函数前。搜索：定位.init_proc函数，但是发现有平坦化混淆：通过D810去混淆结果如下：\nvoid init_proc()&#123;  const char *v0; // x23  __int64 v1; // x0  unsigned int v2; // w0  unsigned __int64 StatusReg; // [xsp+0h] [xbp-870h] BYREF  void *v4; // [xsp+8h] [xbp-868h]  int v6; // [xsp+18h] [xbp-858h]  int v7; // [xsp+1Ch] [xbp-854h]  void *v8; // [xsp+20h] [xbp-850h]  char *v10; // [xsp+30h] [xbp-840h]  FILE *v11; // [xsp+38h] [xbp-838h]  char v12[2000]; // [xsp+40h] [xbp-830h] BYREF  __int64 v13; // [xsp+810h] [xbp-60h]  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 0xD, 0, 2));  v13 = *(StatusReg + 40);  v4 = &amp;StatusReg + -0xFA;  *off_47FB8 = sub_123F0();  sub_12550();  sub_12440();  if ( *off_47FB8 &gt; 23 )    *off_47ED8 = 1;  if ( (sub_25A48() &amp; 1) == 0 )  &#123;    v10 = v12;    memset(v10, 0, 0x7D0uLL);    v2 = getpid();    _sprintf_chk(v12, 0LL, 2000LL, &quot;/proc/%d/cmdline&quot;, v2);    v11 = fopen(v12, &quot;r&quot;);    if ( v11 )    &#123;      v8 = v4;      memset(v4, 0, 0x7D0uLL);      v0 = v4;      fscanf(v11, &quot;%s&quot;, v4);      fclose(v11);      if ( !strchr(v0, 58) )        sub_1BEC4();    &#125;    v1 = sub_13728();    sub_23AD4(v1);    v6 = sub_C830();    if ( v6 != 1 || (v7 = sub_95C8()) != 0 )      sub_9150();  &#125;&#125;\n主要是绕过if ( (sub_25A48() &amp; 1) == 0 )分支，加上这段被混淆了，要善用Graph，下面框中的代码块就是需要绕过的逻辑修改调度器函数如下：然后apply patch，重打包app，安装到手机上，看看效果：耶！成功！！！\n","tags":["安卓逆向"]},{"title":"安卓逆向-抓包","url":"/post/a11b6dd3.html","content":"本文不构成任何技术操作指导或建议，仅供技术交流与学习参考。如发现本文内容存在可能违反法律规定的情况，请立即联系本人删除相关内容。（已对图片中出现的包名和应用名进行处理）\nCharles使用官网网址：https://www.charlesproxy.com网上已经有很多相关的教程了，我这里写一遍有点浪费时间。这里给几个链接：\n\n激活工具：https://down.52pojie.cn/?query=chales\n教程：https://blog.csdn.net/weixin_43612602/article/details/135287720这个教程缺少手机端的操作：下载安装好证书之后，电脑和手机连接到同一个网络，手机WIFI设置中，长按连接的网络，选择修改网络，其中代理选择手动，代理主机名是电脑的IP地址（IP并不是每次都不变的，路由器的ARP表会更新的，所以一段时间之后重新进行代理，一定要记得重新设置一下‘代理服务器主机名’这一项）\n\n端口往往是8888：可以在电脑端Charles中的Help-&gt;SSL Proxying-&gt;install charles RootCertificate on a Mobile……..然后，当开始抓包时，点击Allow即可。\n应用抓包这次的目标是一款心理治愈类APP，它有个挖胶囊的功能，但是每个账号每天只能抓5个胶囊。开始之前，可以先把本地抓包关闭了，只抓手机上的数据包：关闭Windows Proxy。然后挖个胶囊看看怎么个事：先发送一个POST请求，获取Yaoyiyao服务，服务器随机返回一个用户的info，然后APP根据info再次发送info中相关资源的GET请求，获取诸如头像，图片，音乐之类的资源，最后再获取与该info相关的评论。再看看POST请求的param怎么设计的，有哪些参数：我们照着这个请求自己实现一下POST：\nimport requests    URL=&quot;https://服务器/services/v2/xxxx/yaoYiYao&quot;  myparams = &#123;      &quot;userId&quot;:100000,      &quot;longitude&quot;:100,      &quot;latitude&quot;:50,      &quot;blindBox&quot;:0  &#125;  myheader=&#123;      &quot;Content-Length&quot;: &quot;0&quot;,      &quot;Host&quot;: &quot;服务器&quot;,      &quot;Connection&quot;: &quot;Keep-Alive&quot;,      &quot;Accept-Encoding&quot;: &quot;gzip&quot;,      &quot;User-Agent&quot;: &quot;okhttp/4.10.0&quot;  &#125;  response=requests.post(url=URL,params=myparams,headers=myheader)  print(response.text)\n这样就能获得服务了，id可以随意伪造，longitude和latitude也是可以随意伪造的。这个功能有个机制就是每个账号每天只能挖五个胶囊，我们可以设计一下，每请求5次，更改一下账号和经纬度，就能继续获取。我据此实现了一个漂流瓶功能：\nimport requests  import random  import time  import json    class Myhttp:      def __init__(self):          # 基础URL和默认参数          self.base_url = &quot;https://服务器/services/v2/xxxx/yaoYiYao&quot;          self.userId = 100000          self.longitude = 109          self.latitude = 35          self.blindBox = 0            # 通用请求头          self.headers = &#123;              &quot;Content-Length&quot;: &quot;0&quot;,              &quot;Host&quot;: &quot;服务器&quot;,              &quot;Connection&quot;: &quot;Keep-Alive&quot;,              &quot;Accept-Encoding&quot;: &quot;gzip&quot;,              &quot;User-Agent&quot;: &quot;okhttp/4.10.0&quot;          &#125;        def update_params(self):          &quot;&quot;&quot;更新请求参数（随机化）&quot;&quot;&quot;          random.seed(time.time())          temp = random.random()            # 更新参数（使用更合理的随机化逻辑）          self.userId += int(temp * 1000000)  # 随机增加用户ID          self.longitude += (temp - 0.5) * 20  # 经度随机浮动          self.latitude += (temp - 0.5) * 20  # 纬度随机浮动            # 打印当前参数（调试用）          print(f&quot;当前参数: UserID=&#123;self.userId&#125;, 经纬度=(&#123;self.longitude&#125;, &#123;self.latitude&#125;)&quot;)        def post(self):          &quot;&quot;&quot;发送POST请求（无需参数）&quot;&quot;&quot;          try:              # 构建请求参数              params = &#123;                  &quot;userId&quot;: self.userId,                  &quot;longitude&quot;: self.longitude,                  &quot;latitude&quot;: self.latitude,                  &quot;blindBox&quot;: self.blindBox              &#125;                # 发送请求              response = requests.post(self.base_url, params=params, headers=self.headers)              response.raise_for_status()  # 若状态码不是2xx，抛出异常              response_text=json.loads(response.text)              #print(response.text)                return response_text  # 返回JSON格式的响应数据            except requests.RequestException as e:              print(f&quot;请求出错: &#123;e&#125;&quot;)              exit()      def Myprint(msg):      &quot;&quot;&quot;安全地打印消息内容，处理可能的空数据情况&quot;&quot;&quot;      if msg is None or msg.get(&quot;datas&quot;) is None:          print(&quot;没有找到有效的漂流瓶数据，跳过打印&quot;)          return        xxxx_dto = msg[&quot;datas&quot;].get(&quot;xxxxDTO&quot;)      if not xxxx_dto:          print(&quot;没有找到有效的漂流瓶信息，跳过打印&quot;)          return        # 安全获取各个字段的值      xxxx_info = xxxx_dto.get(&quot;xxxxInfo&quot;, &quot;&quot;)      user = xxxx_dto.get(&quot;user&quot;, &#123;&#125;)      nickname = user.get(&quot;nickName&quot;, &quot;无名人&quot;)      city_name = xxxx_dto.get(&quot;cityName&quot;, &quot;未知地&quot;)      create_date_short = xxxx_dto.get(&quot;createDateShort&quot;, &quot;&quot;)      media_url_list = xxxx_dto.get(&quot;mediaUrlList&quot;, &quot;&quot;)        # 打印获取到的信息      print(nickname, &#x27;from&#x27;, city_name, &#x27;\\n&#x27;, xxxx_info, &#x27;\\n&#x27;, create_date_short, &#x27;\\n&#x27;, media_url_list)  # 使用示例  if __name__ == &quot;__main__&quot;:      http_client = Myhttp()        while True:          http_client.update_params()          for i in range(5):              msg=http_client.post()  # 发送请求              Myprint(msg)              time.sleep(2)  # 等待2秒              print(&quot;\\n\\n\\n\\n\\n\\n下一个漂流瓶来咯~~~~~~\\n\\n&quot;)          # 每5次请求后等待更长时间          print(&quot;===== 休息5秒 =====&quot;)          time.sleep(3)\n再加上一点页面：\n","tags":["安卓逆向"]},{"title":"去除某漫画软件启动广告并绕过重打包检测","url":"/post/78290ce7.html","content":"本文不构成任何技术操作指导或建议，仅供技术交流与学习参考。如发现本文内容存在可能违反法律规定的情况，请立即联系本人删除相关内容。（已对图片中出现的包名和应用名进行处理）\n观察正常打开这个apk，就能看到会有启动广告，我们可以看到启动过程的调用栈，首先启动的就是SplashActivity。那清理广告的思路就是替换程序入口。\n\n修改MainActivity.xml文件首先自然是解包（解包和解压不一样哦）\napktool d base.apk -o output\n\n接下来修改清单文件：把这个Activity统统注释掉。然后把MainActivity设置为入口：\n&lt;activity android:configChanges=&quot;screenLayout|screenSize&quot; android:exported=&quot;true&quot; android:name=&quot;com.xxxx.xxxx.MainActivity&quot; android:screenOrientation=&quot;portrait&quot; android:windowSoftInputMode=&quot;adjustPan|stateHidden&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;    &lt;/intent-filter&gt;    &lt;/activity&gt;\n接着就可以重新打包了。签名：\nkeytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore jarsigner -verbose -keystore demo.keystore base1.apk demo.keystore\n然后重新安装上，but：\n排查检测点可以看到，我们的篡改行为被识别出来了，但是好在观察到了启动过程的调用栈启动MainActivity之后跳转到了CheckDialog方法，那我们就在jadx中找到这个方法，但是审计之后，发现这只是一个很普通的日志弹窗的方法，那我们接着查看调用栈，发现有个叫signcheck的类在调用此方法，而MainActivity就是调用了这个检测类。调用栈：MainActivity-&gt;signcheck-&gt;Checkdialog既然是采用Java层方法来检测重打包，那就好办了\n绕过检测点1.frida绕过检测脚本：\nJava.perform(        function()&#123;            let SignCheck = Java.use(&quot;com.xxxx.xxxx(包名).utils.SignCheck&quot;);            SignCheck[&quot;check&quot;].overload(&#x27;android.app.Activity&#x27;).implementation = function (activity) &#123;            return true;        &#125;;    &#125;)\n\n2.修改smali定位~\\output\\smali\\com\\xxxx\\xxxx\\MainActivity.smali给它删咯，再打包。这样就行了。3.其他思路如果继续深扒，signcheck.check调用的是SignCheckUtil.check()，而SignCheckUtil.check()中有字符串b,b就是源文件的SHA1，可以想办法把这串字符改成修改过后APK哈希值\n","tags":["安卓逆向"]},{"title":"安卓逆向基础篇","url":"/post/a6aa1169.html","content":"安卓系统其实安卓系统核心就是Linux系统，保持着“万物皆文件”的特性。\n一、根目录文件夹：\n根目录 (&#x2F;)：系统的最顶层目录，包含系统核心文件和目录链接。\n系统目录 (&#x2F;system)：存放系统核心文件和库。\n/system/app：系统应用的APK文件。\n/system/bin：Linux系统命令和工具。\n/system/etc：系统配置文件。\n/system/framework：系统框架库。\n/system/lib：系统共享库文件（.so）。\n/system/media：系统媒体文件，如铃声、图片等。\n\n\n数据目录 (&#x2F;data)：用户数据和应用程序数据。\n/data/app：用户安装的应用APK文件。\n/data/data/&lt;package_name&gt;：每个应用的私有数据目录。\n\n\n缓存目录 (&#x2F;cache)：临时文件和缓存数据。\n存储目录 (&#x2F;sdcard):外部存储，用户视角下的“根目录”\n设备目录 (&#x2F;dev)：设备文件。\n进程目录 (&#x2F;proc)：系统运行时信息。映射内存中的进程信息\n系统属性文件 (&#x2F;system&#x2F;build.prop)：系统属性配置。\n\n二、Android 启动过程\n\n1. 引导加载程序（Bootloader）启动：  引导加载程序通常存储在设备固件中，类似电脑的 UEFI 固件（或手机的底层引导程序），主要任务是初始化硬件（如 CPU、内存、存储），并加载操作系统内核。其关键功能是验证系统分区的完整性和签名：通过厂商公钥校验核心分区（如boot内核分区、system系统分区、vbmeta签名校验分区）头部的签名数据，确保只有官方认证的系统才能启动。  我们常说的 Bootloader 解锁，是指通过厂商允许的操作（如 Fastboot 指令）触发 Bootloader 的解锁机制，使其不再强制执行分区签名校验（部分厂商会标记 “解锁状态” 并清除校验逻辑），从而允许用户刷入第三方系统或修改系统分区。\n2.内核加载：  引导加载程序会根据预定义的配置从设备存储中加载操作系统内核。\n3.内核初始化：  一旦内核加载到内存中，引导加载程序会将控制权转交给内核。内核开始执行初始化过程，包括对硬件进行初始化、建立虚拟文件系统、创建进程和线程等。\n4.启动 init 进程：  内核初始化完成后，会启动名为init的用户空间进程。init进程是Android系统的第一个用户空间进程，它负责系统的进一步初始化和启动。init进程会读取系统配置文件（例如 init.rc），并根据其中的指令启动系统服务和应用程序。\n5.启动 Zygote 进程：  在init进程启动后，会启动名为Zygote的进程。Zygote进程是Android应用程序的孵化器，它会预加载常用的Java类和资源，以加速应用程序的启动。\n6.启动系统服务（SystemServer）：  在Zygote进程启动后，还会启动一系列系统服务，例如SurfaceFlinger、ActivityManager、PackageManager等。这些系统服务负责管理系统的各个方面，包括显示、应用程序生命周期、包管理等。\n7.启动桌面程序(Launcher)：  一旦系统服务启动完成，Android系统就处于可用状态。就会启动桌面程序，用户可以开始启动应用程序并使用设备进行各种操作了。\n\n三、Android RuntimeJVM安卓的app大多都是由Java或者Kotlin编写的，JVM就是Java程序的运行时环境，但是严格来说不算是安卓运行时。使用Java编写的代码，需要经过javac或者kotlinc编译成.class文件，最后在JVM上个运行。而JVM又可简单分为Class Loader、Runtime Data Area以及Execution Engine三个部分，Class Loader负责从.class加载和分配内存。Runtime Data负责存储数据，分为方法区、堆区、栈区、程序计数器以及本地方法栈。Execution Engine负责二进制代码的执行以及垃圾回收，其中又有Interpreter（解释器执行）和JIT（即时编译）两种执行模式，JIT会把长期执行的热点代码编译成本地机器码缓存起来，后续无需解释可直接执行。\nDalvik针对JVM还要说的是，这是一种基于栈的虚拟机，如果移动端使用这种运行时，必然会对设备的性能要求很高。因此引入基于寄存器的虚拟机——Dalvik。Dalvik虚拟机的可执行文件是.dex，可以通过.class转换得来。Dalvik同样有interpreter和JIT两种执行模式。\nART到了Android4.4，Google推出了新的Android Runtime——ART。为了缩短应用启动时长，采用了AOT（Ahead-of-time）编译方式，即在程序安装时就将dex提前编译成机器码，生成一个oat文件。但这会导致安装时间延长，占用更多的存储空间。\n四、进程创建1.整个过程涉及到多个IPC（进程间通信），主要是binder、sockert机制。\n\nbinder是安卓系统特有的跨进程通信机制，基于 C&#x2F;S 架构，主要用于系统进程和应用进程间通信\nsocket是一种是网络通信方式，多用于跨设备间进程通信，但是同样可以用本地回环地址实现本地跨进程通信。安卓系统中还有一种通信用方式得比较多吧，intent机制，又可以分为显式和隐式两种。但是它是实现的组件间通信，结合binder机制可以实现跨进程的组件通信。\n\n2.进程创建大致分为四个阶段：\n\na. 点击桌面快捷方式之后，Laucher所在进程向system_server发送请求\nb. system_server中的AMS启动Proccess.start，向Zygote发送新建进程的请求。\nc. Zygote进程在系统启动过程开始创建，经过执行ZygoteInit.main()后便进入runSelectLoop()循环体内，当收到创建新的进程请求后，Zygote进程执行ZygoteConnection.runOnce()方法，最后通过fork()创建新进程。\nd. 新建的app进程相当于Zygote的子进程，接着执行handleChildProc方法，最后调用ActivityThread.main()方法。每个阶段都有着较为复杂的函数调用，具体的源码分析移步理解Android进程创建流程\n\n3.下面这个图可以大致解释启动一个app都发生了什么：\n安卓文件结构一、APK文件基本结构我们随便找个apk解压，能看到这样的目录：\n1.assets：存放静态资源文件，如图片、视频等。这些文件不会被编译，而是直接打包到最终的程序中\n2.lib：存放.so库文件，可能会针对不同架构，在其下一级目录设计多个文件夹，如armeabi-v7a、arm64-v8a、x86\n3.META-INF：存放数字签名相关文件，包括MANIFEST.MF、CERT.SF和CERT.RSA\n\nMANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。\nCERT.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。\nCERT.RSA文件中保存了公钥、所采用的加密算法等信息。\n\n4.AndroidMainfest.xml：包含应用程序的基本信息，如包名、版本号、权限、组件等。系统根据这个文件来管理应用程序的生命周期\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- AndroidManifest.xml 是每个 Android 应用的核心配置文件，     用于声明应用的组件、权限、配置信息以及与系统的交互方式 --&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.example.myapp&quot;&gt;    &lt;!-- 声明应用兼容的 SDK 版本范围 --&gt;    &lt;uses-sdk        android:minSdkVersion=&quot;21&quot;        android:targetSdkVersion=&quot;33&quot;        android:maxSdkVersion=&quot;33&quot; /&gt;    &lt;!-- 声明应用期望的设备配置 --&gt;    &lt;uses-configuration        android:reqFiveWayNav=&quot;false&quot;        android:reqHardKeyboard=&quot;false&quot;        android:reqKeyboardType=&quot;nokeys&quot;        android:reqNavigation=&quot;nonav&quot;        android:reqTouchScreen=&quot;finger&quot; /&gt;    &lt;!-- 声明应用需要的硬件或软件特性 --&gt;    &lt;uses-feature        android:name=&quot;android.hardware.camera&quot;        android:required=&quot;true&quot; /&gt;    &lt;!-- 请求应用运行所需的权限 --&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;    &lt;!-- 自定义权限定义，用于保护应用组件 --&gt;    &lt;permission        android:name=&quot;com.example.myapp.MY_PERMISSION&quot;        android:label=&quot;string:permission_label&quot;        android:description=&quot;string:permission_desc&quot;        android:protectionLevel=&quot;normal&quot; /&gt;    &lt;!-- 权限树定义，用于组织相关权限组 --&gt;    &lt;permission-tree        android:name=&quot;com.example.myapp.permission_tree&quot;        android:label=&quot;string:permission_tree_label&quot; /&gt;    &lt;!-- 权限组定义，用于对权限进行逻辑分组 --&gt;    &lt;permission-group        android:name=&quot;com.example.myapp.permission_group&quot;        android:label=&quot;string:permission_group_label&quot;        android:description=&quot;string:permission_group_desc&quot; /&gt;    &lt;!-- 声明测试工具类，用于自动化测试 --&gt;    &lt;instrumentation        android:name=&quot;androidx.test.runner.AndroidJUnitRunner&quot;        android:targetPackage=&quot;com.example.myapp&quot; /&gt;    &lt;!-- 声明应用支持的屏幕尺寸和密度 --&gt;    &lt;supports-screens        android:resizeable=&quot;true&quot;        android:smallScreens=&quot;true&quot;        android:normalScreens=&quot;true&quot;        android:largeScreens=&quot;true&quot;        android:xlargeScreens=&quot;true&quot;        android:anyDensity=&quot;true&quot; /&gt;    &lt;!-- 应用定义标签，包含应用的全局属性和组件 --&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;!-- Activity 组件声明，用于提供用户界面 --&gt;        &lt;activity            android:name=&quot;.MainActivity&quot;            android:label=&quot;@string/app_name&quot;            android:exported=&quot;true&quot;&gt;            &lt;!-- Intent Filter 定义 Activity 可以响应的 Intent 类型 --&gt;            &lt;intent-filter&gt;                &lt;!-- 声明此 Activity 可以作为应用入口点 --&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;!-- 声明此 Activity 应显示在应用启动器中 --&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;!-- Activity 别名声明，用于为现有 Activity 提供替代入口 --&gt;        &lt;activity-alias            android:name=&quot;.MainActivityAlias&quot;            android:targetActivity=&quot;.MainActivity&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;            &lt;!-- 元数据定义，用于存储额外配置信息 --&gt;            &lt;meta-data                android:name=&quot;additional_info&quot;                android:value=&quot;alias_info&quot; /&gt;        &lt;/activity-alias&gt;        &lt;!-- Service 组件声明，用于在后台执行操作 --&gt;        &lt;service            android:name=&quot;.MyService&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;false&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;com.example.myapp.MY_SERVICE&quot; /&gt;            &lt;/intent-filter&gt;            &lt;meta-data                android:name=&quot;service_config&quot;                android:value=&quot;config_value&quot; /&gt;        &lt;/service&gt;        &lt;!-- BroadcastReceiver 组件声明，用于监听系统或应用事件 --&gt;        &lt;receiver            android:name=&quot;.MyReceiver&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;            &lt;/intent-filter&gt;            &lt;meta-data                android:name=&quot;receiver_data&quot;                android:value=&quot;data_value&quot; /&gt;        &lt;/receiver&gt;        &lt;!-- ContentProvider 组件声明，用于跨应用共享数据 --&gt;        &lt;provider            android:name=&quot;.MyContentProvider&quot;            android:authorities=&quot;com.example.myapp.provider&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;false&quot;&gt;            &lt;!-- 声明允许访问的 URI 权限 --&gt;            &lt;grant-uri-permission                android:path=&quot;/data&quot;                android:pathPattern=&quot;/.*&quot;                android:pathPrefix=&quot;/images&quot; /&gt;            &lt;meta-data                android:name=&quot;provider_info&quot;                android:value=&quot;provider_value&quot; /&gt;        &lt;/provider&gt;        &lt;!-- 声明应用需要链接的共享库 --&gt;        &lt;uses-library            android:name=&quot;android.test.runner&quot;            android:required=&quot;true&quot; /&gt;    &lt;/application&gt;&lt;/manifest&gt;\n5.classes.dex：包含应用程序的所有Java类和方法，是应用程序的可执行文件。它是一个被编译过的DEX（Dalvik Executable）文件，用于在Android设备上运行Java代码，通常不止一个。\n6.resources.arsc：包含应用程序的所有资源信息，如布局文件、字符串、图片等。这个文件在应用程序编译过程中由aapt工具生成，并被打包进APK文件中\n二、ELF文件格式ELF是unix系统的二进制文件。前面说过安卓是基于Linux内核，如 init（系统初始化进程）、zygote（安卓应用孵化器）都是ELF文件，APP的动态链接库也是ELF文件。\nELF Header:描述了描述了体系结构和操作系统等基本信息并指出Section Header Table和Program Header Table在文件中的什么位置Program Header Table: 保存了所有Segment的描述信息Section Header Table:保存了所有Section的描述信息\n常见字段含义：\nGOT\n全称：Global Offset Table（全局偏移表）。\n位置：数据段（.got&#x2F;.got.plt）。\n作用：存储全局变量和外部函数的地址，运行时可被动态链接器修改。\n\nPLT\n全称：Procedure Linkage Table（程序链接表）。\n位置：代码段（.plt）。\n作用：包含汇编指令，实现外部函数的延迟绑定和调用跳转。\n特性：程序加载后不可修改（只读），但可通过 GOT 间接控制跳转目标。\n\n重定位重定位（Relocation）是计算机程序链接和加载过程中的关键机制，用于解决程序中符号（如函数、变量）地址的动态分配问题。简单来说，它是将程序中符号的逻辑地址转换为实际物理地址**的过程。那么在Linux系统中，重定位的过程实际就是通过GOT表和PLT表来实现的。可以分为两个阶段：\n\n链接重定位：也叫静态重定位。在链接阶段，当发现函数是外部函数时，链接器在PLT段生成一段跳转代码PLT Stub,然后将代码中调用该函数的地址换成stub的地址\n运行时重定位：也叫动态重定位。在运行时，把外部函数的地址加载到got表中，调用该函数时，通过plt调转到got表中存储的地址实现调用。\n\n延迟绑定延迟绑定指的是将外部函数地址的解析推迟到首次调用时，从而减少程序启动时间。程序启动时，仅初始化 PLT（程序链接表）和 GOT（全局偏移表）的结构，不立即解析函数地址。静态重定位是在给延迟绑定做准备，动态重定位是在执行阶段。与延迟绑定对应的是立即绑定。 动态链接器遍历所有外部符号（如printf、malloc)。 一次性解析所有符号的真实地址，并更新 GOT 表。 直接通过 GOT 表中的真实地址调用，无需动态链接器介入。\n参考文档Android目录结构全解析Android启动流程理解Android进程创建流程深入理解Android-RuntimeAndroidManifest.xml 最全详解Android Hook技术学习——常见的Hook技术方案总结\n","tags":["安卓逆向"]},{"title":"除水印小程序逆向分析","url":"/post/1ebbdde9.html","content":"​        大家都能发现，现在的手机应用隔三差五就要更新，存储空间的需求还越来越大，而各类平台的小程序凭借着面相用户轻量便捷，面相平台丰富生态的作用越来越受到市场的追捧。小程序介于网页端和应用端，同时具备了两者的优点，甚至有些厂商渐渐砍掉应用的研发，转而开发和维护小程序端口。但是目前的小程序安全却是良莠不齐，有的层层加固，有的直接裸奔。\n​       本文记录了对一个去除视频水印小程序的逆向过程：\n解密与解包：我们使用wedecode这个开源项目进行解密和解包。\n加密工具使用时，如果小程序包已从原Applet地址移出，也应当保留小程序包上两级的路径，如： ~\\Applet\\wx1680cca9a19ee3c8\\48\\__APP__.wxapkg&quot;。“wx1680cca9a19ee3c8”这一字符串应当保留，与解密有关（采用的AES加密，这个字符串与秘钥生成有关，后面比对发现，这个字符串同时也是APPID。）\n然后使用wedecode解包后，使用微信开发者程序打开调试。可能因为文件解包的问题，或多或少都会遇到几个文件语法格式的问题：\n\n我们得根据提示一个一个修正：\n\n app.json: componentFramework 字段需为 exparser,glass-easel componentFramework 字段需为 string\n\n&quot;componentFramework&quot;: &#123;  &quot;allUsed&quot;: [    &quot;exparser&quot;  ],  &quot;default&quot;: &quot;exparser&quot;&#125;,\n\n修改为：\n&quot;componentFramework&quot;:&quot;exparser&quot;,\n\n\n \napp.json: [“tabBar”][“list”][0][“iconPath”] should not contain \\\n把全部的“\\\\”替换成“&#x2F;”,\n\n\n重新编译之后就可以运行：\n分析核心功能：定位index.js中的query方法。\nquery: function(e) &#123;  var a = this,    n = a.isUrl(a.data.inputvalue);  n &amp;&amp; wx.showLoading(&#123;    title: &quot;正在解析&quot;  &#125;) &amp;&amp; (wx.request(&#123;    url: t.globalData.url + &quot;query&quot;,请求体    data: &#123;      url: n,      token: wx.getStorageSync(&quot;token&quot;),      id: wx.getStorageSync(&quot;id&quot;),      user_id: t.globalData.user_id    &#125;,    success: function(t) &#123;      wx.hideLoading(), 104 == t.data.code ? wx.showModal(&#123;        title: &quot;提示：&quot;,        content: t.data.message,        confirmColor: &quot;#ff9900&quot;,        showCancel: !1,        success: function(t) &#123;&#125;      &#125;) : (wx.hideLoading(), a.setLog(a.data.inputvalue), 3 != t.data.data.type ? a.setData(&#123;        title: t.data.data.title,        photo: t.data.data.photo,        downurl: t.data.data.downurl,        url2: t.data.data.url2 ? t.data.data.url2 : 0,        pics: t.data.data.pics      &#125;) : (wx.setStorageSync(&quot;picsaa&quot;, t.data.data), wx.navigateTo(&#123;        url: &quot;pagespicshhindex&quot;      &#125;)))    &#125;  &#125;), setTimeout((function() &#123;    o &amp;&amp; a.data.ad_chaping &amp;&amp; o.show().catch((function(t) &#123;      console.error(t)    &#125;))  &#125;), 2e3))&#125;,\n\n在app.js中找到globalData对象：\n  .........  globalData: &#123;    url: &quot;https:qq.yyymvp.com&quot;,    user_id: 8  &#125;&#125;);\n\n从业务代码可知，请求体是：\nwx.request(&#123;      url: t.globalData.url + &quot;query&quot;,请求体      data: &#123;        url: n,        token: wx.getStorageSync(&quot;token&quot;),        id: wx.getStorageSync(&quot;id&quot;),        user_id: t.globalData.user_id      &#125;,\n\n可以看到它的安全性确实太低了，token和id都是不验证的，userid就是硬编码的。那么这个工具的小程序后台我们就可以直接使用了，避免烦人的广告。\n简易代码如下：\nimport requestsUrl=&quot;https:qq.yyymvp.com&quot;o_url= &quot;https:example&quot;user_id=8token=&#x27;&#x27;id_=&#x27;&#x27;data=&#123;    &quot;url&quot;:o_url,    &quot;token&quot;:token,    &quot;id&quot;:id_,    &quot;user_id&quot;:8&#125;res=requests.post(    Url+&quot;query&quot;,    data=data,)res_text=res.json()print(res_text[&#x27;data&#x27;][&#x27;downurl&#x27;])\n\n我们可以把它部署在自己的电脑上，或者编写一个短小的程序，供自己使用。\n 除水印小程序.py \n","tags":["小程序逆向"]},{"title":"Frida用法快查表","url":"/post/453c1aa4.html","content":"一、处理重载方法（Overloads Handling）场景：区分同名但参数类型不同的方法（如 int 和 String 输入的不同逻辑）关键点：使用 .overload() 指定参数类型，或通过 .overloads 遍历所有版本\nvar MyClass = Java.use(&#x27;com.example.MyClass&#x27;);// 指定参数类型为 int 和 String 的重载方法MyClass.myMethod.overload(&#x27;int&#x27;, &#x27;java.lang.String&#x27;).implementation = function(a, b) &#123;    console.log(`参数: $&#123;a&#125;, $&#123;b&#125;`);    return this.myMethod(a, b); // 调用原始方法&#125;;// 遍历所有重载版本MyClass.myMethod.overloads.forEach(overload =&gt; &#123;    overload.implementation = function(...args) &#123;        console.log(`重载方法调用，参数类型: $&#123;args.map(arg =&gt; arg.type)&#125;`);        return this.myMethod(...args);    &#125;;&#125;);\n二、构造函数 Hook（Constructor Hooking）场景：篡改对象初始化参数（如绕过校验逻辑）限制：避免直接 Hook Android 组件生命周期（如 Activity 实例化）\nvar Checker = Java.use(&#x27;com.example.Checker&#x27;);Checker.$init.overload(&#x27;int&#x27;, &#x27;int&#x27;).implementation = function(a, b) &#123;    console.log(`原始构造参数: $&#123;a&#125;, $&#123;b&#125;`);    // 强制修改构造参数    this.$init(1234, 4321); // 调用修改后的构造函数&#125;;\n\n三、动态实例操作（Dynamic Instance Manipulation）场景：调用未主动触发的隐藏方法，或获取内存中对象数据（如解密密钥）优势：直接操作运行时对象，无需依赖代码逻辑触发\nJava.choose(&#x27;com.example.MainActivity&#x27;, &#123;    onMatch: function(instance) &#123;        console.log(`找到实例: $&#123;instance&#125;`);        instance.secretMethod(); // 调用隐藏方法        // 获取实例字段值        console.log(`私有字段值: $&#123;instance.privateField.value&#125;`);    &#125;,    onComplete: () =&gt; console.log(&#x27;实例遍历完成&#x27;)&#125;);\n\n四、Native 层 Hook（Native Function Interception）场景：监控 C&#x2F;C++ 原生函数（如文件操作、网络通信）扩展：结合 Stalker 追踪代码执行路径\nconst openPtr = Module.findExportByName(&#x27;libc.so&#x27;, &#x27;open&#x27;); // 定位原生函数地址Interceptor.attach(openPtr, &#123;    onEnter: function(args) &#123;        // 读取 C 字符串参数        const filename = Memory.readUtf8String(args[0]);        console.log(`打开文件: $&#123;filename&#125;`);        // 修改参数（示例：拦截并返回特定文件描述符）        // args[0] = Memory.allocUtf8String(&#x27;/dev/null&#x27;);    &#125;,    onLeave: function(retval) &#123; // retval 为原生函数返回值        console.log(`返回值（文件描述符）: $&#123;retval.toInt32()&#125;`);    &#125;&#125;);\n\n五、静态方法与全局变量操作（Static Methods &amp; Variables）注意：静态方法需正确匹配参数类型，避免因重载导致 Hook 失效\nvar MainActivity = Java.use(&#x27;com.example.MainActivity&#x27;);// 修改静态变量（如全局配置项）MainActivity.staticVar.value = 512; // 直接赋值// 钩取静态方法MainActivity.staticMethod.implementation = function() &#123;    console.log(&#x27;静态方法被 Hook&#x27;);    return &quot;Hijacked!&quot;; // 替换返回值&#125;;\n\n六、批量 Hook 所有重载方法（Bulk Overload Hooking）场景：快速覆盖混淆代码中的所有方法重载版本\nfunction hookAllOverloads(className, methodName) &#123;    const clazz = Java.use(className);    clazz[methodName].overloads.forEach(overload =&gt; &#123;        overload.implementation = function(...args) &#123;            console.log(`[$&#123;methodName&#125;] 调用参数: $&#123;args&#125;`);            // 可选：修改参数（如固定第一个参数为 0）            // args[0] = 0;            return this[methodName](...args); // 调用原始方法        &#125;;    &#125;);&#125;// 使用示例：批量 Hook 所有重载的 `parse` 方法hookAllOverloads(&#x27;com.example.Parser&#x27;, &#x27;parse&#x27;);\n\n七、参数与返回值篡改（Argument &amp; Return Value Manipulation）技巧：结合 Frida Python 端 send() 实现动态策略调整\nMyClass.check.implementation = function(a, b) &#123;    // 修改输入参数（固定第二个参数为 100）    const result = this.check(a, 100);     // 反转校验结果（示例：通过校验时返回失败）    return result === 0 ? 1 : 0; &#125;;\n\n八、工具链扩展（Toolchain Integration）1. Frida-trace 快速追踪命令：追踪所有以 open 开头的原生函数，以及 Java 层 Socket 相关方法\nfrida-trace -U -i &quot;open*&quot; -j &#x27;*java.net.Socket*&#x27; com.example.app\n\n2. 内存操作（Memory API）场景：直接读写进程内存，绕过加密逻辑\n// 读取指定地址的 4 字节整数const value = Memory.readInt(ptr(&#x27;0x7aabbcc0&#x27;)); // 写入字符串到内存（自动计算长度）Memory.writeUtf8String(ptr(&#x27;0x7aabbcc0&#x27;), &#x27;hacked&#x27;);\n\n附：常用命令行参数\n\n\n参数\n说明\n\n\n\n-U\n通过 USB 连接设备（默认优先选择 USB 设备）\n\n\n-f &lt;包名&gt;\n启动指定应用并注入脚本（自动 attach）\n\n\n-l &lt;脚本.js&gt;\n加载指定 JavaScript 脚本\n\n\n-D &lt;设备ID&gt;\n连接指定 ID 的设备（多设备场景）\n\n\n","tags":["安卓逆向"]},{"title":"熊猫烧香病毒分析（下）","url":"/post/a79f02af.html","content":"最后进行病毒专杀和文件修复的工作。\n病毒专杀：由于现流行的编程语言版本和编译器版本编写专杀工具需要解决兼容win7_x32的问题，我就不花心思去解决了。我们可以使用批处理文件来实现。\n程序需要实现的功能：\n\n \n删除并结束spo0lsv进程\n\n \n遍历每个盘，找到并删除setup.exe和autorun.inf，要避免误杀同名文件。\n\n \n遍历路径，查找并删除Desktop_.ini,同样要避免误杀同名文件。\n\n \n修改注册表，删除Software\\Microsoft\\Windows\\CurrentVersion\\Run\\svcshare和SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\Hidden\\SHOWALL\\CheckedValue\n\n\n批处理文件实现：@echo offsetlocal enabledelayedexpansionREM 提升为管理员权限（需保存为.bat运行）NET FILE &gt;NUL 2&gt;&amp;1 || (powershell -Command &quot;Start-Process &#x27;%~f0&#x27; -Verb RunAs&quot; &amp; exit b)REM ██████ 终止进程并删除驱动文件 ██████taskkill F IM spo0lsv.exe &gt;nul 2&gt;&amp;1if exist &quot;C:\\windows\\System32\\drivers\\spo0lsv.exe&quot; (    attrib -H -S &quot;C:\\windows\\System32\\drivers\\spo0lsv.exe&quot; &gt;nul 2&gt;&amp;1    del F Q &quot;C:\\windows\\System32\\drivers\\spo0lsv.exe&quot; &gt;nul 2&gt;&amp;1    echo 已删除 spo0lsv.exe)REM ██████ 遍历所有盘符删除隐藏的病毒文件 ██████for f &quot;skip=1&quot; %%d in (&#x27;wmic logicaldisk where &quot;DriveType=2 OR DriveType=3&quot; get name&#x27;) do (    set &quot;drive=%%d&quot;    if defined drive (        echo 深度扫描盘符: !drive!                REM ─── 处理根目录隐藏文件 ───        for %%f in (&quot;!drive!\\setup.exe&quot; &quot;!drive!\\autorun.inf&quot;) do (            if exist %%f (                attrib -H -S -A %%f &gt;nul 2&gt;&amp;1                del F Q %%f &gt;nul 2&gt;&amp;1                echo 已清除根目录隐藏文件: %%f            )        )                REM ─── 递归处理子目录（含隐藏文件）───        for f &quot;delims=&quot; %%f in (&#x27;dir !drive!\\* s b a:-d a:h 2^&gt;nul ^| findstr i &quot;\\\\setup.exe$ \\\\autorun.inf$&quot;&#x27;) do (            set &quot;filepath=%%f&quot;            REM 排除系统关键路径            if not &quot;!filepath:\\Windows\\=!&quot;==&quot;!filepath!&quot; (                echo 跳过系统文件: %%f            ) else if not &quot;!filepath:\\Program Files\\=!&quot;==&quot;!filepath!&quot; (                echo 跳过程序文件: %%f            ) else (                attrib -H -S &quot;%%f&quot; &gt;nul 2&gt;&amp;1                del F Q &quot;%%f&quot; &gt;nul 2&gt;&amp;1                echo 已删除隐藏病毒文件: %%f            )        )    )):: 全盘遍历所有Desktop_.ini（严格匹配带下划线的文件名）set &quot;drive=C:&quot;REM 递归搜索并强制删除所有隐藏的Desktop_.ini文件for f &quot;delims=&quot; %%f in (&#x27;dir a:h s b &quot;%drive%\\Desktop_.ini&quot;&#x27;) do (    del F Q A:H &quot;%%f&quot; &gt;nul 2&gt;&amp;1    if exist &quot;%%f&quot; (        echo 删除失败（可能被占用或权限不足）: %%f    ) else (        echo 已删除: %%f    ))REM ██████ 注册表修复 ██████reg delete &quot;HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\svcshare&quot; f &gt;nul 2&gt;&amp;1reg delete &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\Hidden\\SHOWALL\\CheckedValue&quot; f &gt;nul 2&gt;&amp;1echo 注册表修复完成pause\n\n文件恢复：逆向感染代码：我们重新关注C_InfectFile(sub_407F00):\n\n大致逻辑：\n\n是把自己复制到目标文件目录下，伪装成目标文件（直接覆盖目标文件）\n\n把目标文件附加到伪装文件之后\n\n再在伪装文件之后添加一段字符串（”WhBoy”+”原文件名”+“.exe”+02+“原文件字节数”+01）\n\n这就实现了病毒“感染”。\n\n\n编程文件恢复：流程如下：\n\n 识别被感染的病毒——可以通过末尾字符串识别。\n 删除病毒部分——删除文件前30001个字节，这个部分应该建议通过计算原病毒大小来动态处理。\n 删除文件最后的字符串标识。\n\n批处理文件实现：代码如下：\n::C:\\Program Files\\IDA 6.8\\idaw64.exe@echo offsetlocal enabledelayedexpansion:: 必须用管理员运行（右键选&quot;以管理员身份运行&quot;）set &quot;target_file=文件路径&quot;:: 阶段1：安全截断前30001字节powershell -Command &quot;$f=&#x27;%target_file%&#x27;; if (Test-Path $f) &#123; $b=[IO.File]::ReadAllBytes($f); [IO.File]::WriteAllBytes($f, $b[30001..($b.Length-1)]) &#125; else &#123; exit 1 &#125;&quot;:: 阶段2：精准解析尾部标识符powershell -Command &quot;$f=&#x27;%target_file%&#x27;; $bytes=[IO.File]::ReadAllBytes($f); $sepIndex=$bytes.Length-1; while($sepIndex -ge 0 -and $bytes[$sepIndex] -ne 2)&#123;$sepIndex--&#125;; $numStr=-join[char[]]$bytes[($sepIndex+1)..($bytes.Length-1)] -replace &#x27;[^0-9]&#x27;,&#x27;&#x27;; [IO.File]::WriteAllBytes($f, $bytes[0..([int]$numStr-1)]); echo 修复成功，最终大小: $numStr 字节&quot;pause\n\n\n心得：  这个病毒总的分析下来学到很多东西，编写者具有很强的工程思维，逻辑缜密，代码功力也很强。\n最后：\n\n\n太恐怖了，一觉醒来，就要攻击宿主机了。虚拟机网络还是设置成hostonly模式，并且宿主机关闭该局域网的”Internet 协议版本4（TCPIPv4）”才是安全的。\n","tags":["病毒分析"]},{"title":"熊猫烧香病毒分析（上）","url":"/post/1f2365ca.html","content":"准备样本信息：\n文件名：xiongmao.txt\nMD5：512301c535c88255c9a252fdf70b7a03\nSHA256:40fee2a4be91d9d46cc133328ed41a3bdf9099be5084efbc95c8d0535ecee496\n大小：30,001 字节\n实验环境与工具：虚拟环境：windows_7_ultimate_with_sp1_x86\n工具：IDA_Pro、x64dbg、PCHunter、HRSword、DIE_win32   （由于HRSword进程总是被病毒干掉，得结合着PCHunter和录屏来看）\n行为分析tips:由于是在win7系统中进行的行为分析，我们需要使用以管理员身份运行。在win xp系统中，默认用户拥有管理员权限，无需授权的执行就可以修改系统文件，这也就给计算机病毒提供了温床。\n1.启动资源管理器发生闪退病毒成功运行。\n2.复制到drivers路径下：\n并创建相关启动项\n\n\n3.程序的exe文件被“感染”\n4.创建大量Desktop.ini文件几乎每个路径下都有，只写入了创建时间。\n\n\n5.在C盘根目录下创建setup.exe和autorun.inf\n两个文件有隐藏属性\n\n病毒作者意图是访问c盘或插入U盘时，自动启动setup文件，但这个样的设计已经在win7即更高版本的Windows系统中失效。\n- Windows 7 及更新系统默认禁用 U盘移动硬盘的 autorun.inf 自动运行功能（仅保留光驱支持）。- 需手动打开设备或触发右键菜单才会执行程序。\n\n6.网络方面\n\nSYN_SENT 状态（端口139）： 大量向不同内网IP的139端口发起连接请求，表明内网扫描行为，用于探测漏洞或横向传播恶意软件（如利用SMB协议漏洞）。\nESTABLISHED 状态（端口80）： 成功连接至192.168.42.1:80，可能意图是恶意软件与C2服务器通信或数据外传\n\n二进制文件分析：查壳与脱壳：查壳：是有壳的。FSG工具打包\n\n简单说一下怎么脱，上面的DIE被扰乱了，实际只有FSG壳，这个样本同时具有FSG壳OEP特征和DelPhi编译器入口特点，很好找OEP，scylla普通模式找IAT表，然后dump+fix dump，就可以了。\n\n\n\n能看到还是恢复了很多东西。\n逆向伪代码分析：\n\nj_XXXXX是识别出来的系统函数名\nC_XXXX是分析过后的自定义的，逻辑分析得比较清晰可信的函数名\nM_XXXX是未细致分析过的自定义的，根据上下文初步猜测的函数名\nsub_XXXX则是IDA根据函数偏移命名的函数名\n\n动态调试分析：通过调试结果，观察运行后变量表现，推测函数功能\n执行前：（C_GetAbsolutePath）\n\n执行后：\n\n\n参数在函数执行前后的变化很明显，获得该程序的绝对路径。\n静态分析：通过对已确认函数名的调用，分析该函数的功能：\n\n通过j_GetCommandLineA和j_GetModuleFileNameA可以分析出sub_40277c与获取路径相关。\n分析结果：C_mian（部分）:\nC_GetParentCatalogue：\n未完待续~~~","tags":["病毒分析"]},{"title":"熊猫烧香病毒分析（中）","url":"/post/22c6f24d.html","content":"\nsub_40819C:预备阶段实现对原病毒所在路径下的desktop.ini文件的删除和将自己复制到drivers路径下并启动\nv55 &#x3D; __readfsdword(0)sub_40819C函数开头的 v55 &#x3D; __readfsdword(0)可以反编译成\nExceptionList = NtCurrentTeb()-&gt;NtTib.ExceptionList;\n\n和\n__writefsdword(0, &amp;v55);\n\n一起处理异常。\n查找Desktop_.ini并删除：检测是否存在该文件，若存在，先修改其属性为隐藏，再进行删除。\n\n这段代码并不是我们之前观察到的创建Desktop_.ini文件实现代码。\n自我复制到C:windowsSystem32drivers路径下：先检测是否已经存在该进程和文件，有就先kill该进程和修改属性，再获取System32路径，拼接路径，自我复制到驱动目录下再运行，最后退出当前进程。\n\nsub_407B68（）：自毁程序:try1del &quot;原程序.exe&quot;      → 尝试删除被锁定的程序文件if exist &quot;原程序.exe&quot; goto try1 → 循环检测直到进程退出ren &quot;原程序.exe&quot; 临时名称 → 解除文件锁定后重命名del 临时名称          → 删除重命名后的文件del %0               → 最后删除批处理自己\n\n当程序自然退出后，批处理文件将会开始执行。\nsub_40D18C:爆发阶段实现对各目录下Desktop_.ini文件的创建，对其余文件的感染，和setup.exe文件的创建，以及实现内网横向渗透\nsub_0040A5B0:创建线程执行：sub_40A48C：\n\n来执行遍历路径，创建Desktop_.ini文件和感染可执行文件的逻辑（读取系统时间并写入）：\n\n感染可执行文件相关：\n\nC_InfectFile：\n\nsub_40C374：设置一个6s的计时器运行TimerFunc函数，TimerFunc核心逻辑就是在系统盘创建setup.exe和相应的自启动文件autorun.inf。\nsub_40BACC： 创建线程，执行网络连接，实现横向内网渗透，通过SMB协议扫描：\nSystem::BeginThread(sub_40BA8C, 0, 0, &amp;v6, 0, 0, v3); 多线程运行,横向内网渗透，\n\nsub_40D088:对抗安全查杀恶意下载与执行相关，对抗安全软件和监控\n设置了6个计时器：\n\n\n\n定时器地址\n时间间隔\n回调函数\n功能描述\n\n\n\n0x3E8u\n1秒\nsub_40CEE4\n创建自启动项 (spo0lsv)，实现持久化\n\n\n0x124F80u\n20分钟\nsub_40D040\n核心恶意下载模块（可能下载远控木马或勒索组件）\n\n\n0x2710u\n10秒\nsub_40D048\n下载后抹除痕迹（删除日志、加密通信等）\n\n\n0x1770u\n6秒\nsub_407430\n系统性终止安全软件服务，删除注册表启动项（针对性对抗杀软）\n\n\n0x2710u\n10秒\nsub_40CC4C\n隐蔽数据下载（可能用于泄露敏感信息或接收指令）\n\n\n0x1B7740u\n30分钟\nsub_40C728\n二次恶意下载（更新组件或下载额外攻击载荷）\n\n\n特别是在sub_40CEE4函数中的sub_406E2C函数：\n执行sub_4061B8，实现通过关闭安全软件窗口、终止关键进程、模拟用户操作，破坏系统防御能力，确保恶意程序持续运行：\n\n最后把分析的思维图放到最后：\n\n","tags":["病毒分析"]},{"title":"校园跑方案（同天智慧树）","url":"/post/run.html","content":"\n  4630436162ade97ba2718b7d0c4b3b63cb3a3f659c5ca08b4bca0f5845928186fc2e4ebfd0709bfd9a0400faa9ff57a037205f1fd37f149dc05dcac635cd218db17c5656f86519b8edeb5851fb0b8e42387fc63b3d693c0812101f9e8455f5fa80e1e03af195a740bf8f15206bed393a5c0f9830cbdbcabe439fe476bff6e6d786c156bc6e4b5cab751cd21c285d67d5db20d8ecaae7bb50066473ff26eee664bbc58b154b8ddb31dd72e29e6d0cee6c7fd07fc846029b84f8ff51c482d6139cb45643da17e2c2e8c2d15953a99ee105d06f1891bb3c965d2e904e24f2193dd886eb8b8c1bff8facc2a88c3c23b236e9c75f1925a819f0d65d4188cc5ee85d2ee00124995b26fa7e6e2a5196642f3cb7664fd2b9a0476cf6b8668b556dd470b302f8324a2420ec7db1316092818917f7b579f00a9e83672db7880076348e2a6e37caefcaa39679367fdef98e44b833a72283950ddc108999c7e76f83da52915c10dcf8b58566167ad0d7ece02f2a4161d29d884b29f73c418bad22923c176f2e3dd3ff72702904dcfa650735ea6f02e121427f620256de185bde0d752613493bdde1b03684bf50d1f296eb2c08b0d9eb5d256364f02bccdd774f3aacec415f2d8c406ec686ec11f7c9d811f7bb2b644bdee0f1bd4407451f04c6bc2d384f289c3aa0ed2f573339d708440690ee34c12848ddeafe0b66b10a75477cedfa0808d8ac574993f8d4c3b90cb282c033833a282e73e741fdce3ba6853e97f3e26dce2f4bec62c261991bc91e699988cf073cd4b6810a8c792b5e6d736664189a76302cde3419a36e512f528b8e3f9dc1938d5377ddefdcd664ccb4f076a229a02a899d6e0227dac836361f026b2c774767a2e4902dfb143fc493d547d5c12a8e6156b40d11b78ae769964a227df045b7c6b9b6a727b71a745704973546aabb0cf97913f36f1baec58d5ff627fdcc245eba4afa33a054d1691c88dcc4c71d6bfc81a16638ad7404251d017f7e1ac4364fc5e8f330881fcd8f5e5775fe2339444016b1582c10fd50314033c370eb62ebf8730a0fab67d419e79b6e52ba7d2f3454aa11748cc5141d72fe3d9da72a35caf452b7adc5eb0fdcc169151e3c86dea0396ed07c21b2a8a3b935cb95262f8ae78588b88b189462e39495fa5a991f72355f3731ae1946e9ed56bad548d795c599ad184bfe443436192ff3c3c8d5e73cf49a3b3d39e7c722f7633679ca9df1a501656be72ac9578b43b46da712d135822a8067ad0519e97dab986773acc877943993ed470da2c5dcf540c01ecb3d5e217a4071920ea99109452210bbd10f9730688396899ae78712794181e914383e267dc581b53a5073d582bc8e2e28eafe234f0c78bac9fb9309530b981d9276d98988cb534ce36eefacf7c6dfe5f715b25101fe64feec88ea89079d21a719e4c311419f495c881df20ca3834858498eb3e61d7cf2ee8f52ef671eb636d82023421e5c47f498d5a4b5f839746c37ec64aeb9b3ec6ff05b3e5d88b143534b8e20dd1f78590a64d2c5f86142819103f9608ec0b8b34ee45be4854e4b65609ad653814569a6753fe11a6c1346cab49885d6a616d735470a858a4f855a5f59926390d64046e925325afcfff155e17fb71fcb2b65600a66fe14c090c292c71e252eeef9faadfad513990f70ba94a7d5cdacebd27413e3c463e528efa8f0d69faad677f000b15c3357c5eefb24d10b7d2f514407ceb1af4976fa232270aaddd554ff1b1f4e11405573d26bc4b5c4df03f3397abd8b3251c370fa99c147b5df11b9655f29493bcb91a8204cc34257872ce39613d9372f7b2c35eb14205f64dd790300ffb00bd5430d9c684b9fbdbf2e284bb87d10894d13d45f500737b7546bf75f986312ba4f0bbac54d7fec526e4431cb0e29b3d59b8fb6c05fb22d17c7e34f30de3149d745073771820ee08ea5edf3b380b85a6c9bbe752dd30ca227a7d3279e5f1126ff65c97b1628566440fd853867335133dd1dc121e5996db9431aa0dc28cba052d9837d61c355c3a9ca89aeaa55000fd115087768158ba79dbd0439f457096b4cb4c5639757015abffeb736f9a61b842bad7384d6f9c80b7950c9428d5c4ed6aee8f2bd326258c682282b8ef49280b8127f7d57dca6640d0593c186b0f752555711a9c51fada68792535568e08257d4cda1bc13f108b0c77a3ec93d48a9270c9ab743ebbb8163360b8b06b417e22074921b4d8034162ad8a3cf9cf37d0e4ec1b513dfce6a4ef742c3261b543e378b07eb6d832c0e52568b1663fe01cdc41fc425e3d56df547c37f1c0bd2d99819ab33fd0e50df2971a5ed2e9909aeb39bea3a36daea10ce26df8eb7f8c1ffe0ebfeb684c8e18c7915f1d71f4a429a39a078d5a49855df128e3dfe9bc6de04cd4c111aed6ed915b7ee68d570939a5782eddde689b64060e77d8c667a5e1ed3443e39f5b964279b03b35db4b75ac3955261ef5b8228ed9d7e40c860adf3eaff408603df72834d629b18dd9dca1944045c60935bc99fcf3dc84f2c28a598b5b8db68efb15ac3d685fc2bc42f6be216f8079fe41a5dea173cfb113bbfcc4756b9fc3b49a4119abe6530dad6fdfcb3a9cce13655ae45e7c8f67ab8967960f012c68de61e71114a90e3e16ef304e9ade5121c4475cc54c66fa49a15cc7175d5dd989956444e4033dded88a03cb4324f220f2de778c69cb0b9a3abd3036a1875e4b0948f3383425ccf3889e109a055a0f2c3735bd09a1cf7297d93e7b62efc9607925de850e3bee0c6b2c2238e2f2dd8da43793b176b30128381d5fa8595b176d24b39f9d4ea4ef446c0ced7c50a630acc96af25ff1ae68846558babe3f8cc87af9a3377acc33ea7200811ec98e649113ed48640e8a20a31877f45665a847fe77454e02891f0a45bace2e03d99072dd9f9db123b385782836352a504e6cde08851069ef6b870f6a3da19fd48545eb6ef443efd02e9de7cfeb350161bad8eaddb9f82db04aeed3db2d234ba73683a2d851ee63a0f1f0801b9db57567872141c66076d000842aeba24a181266168877c273f57b5b5c3d96a2c6fd2db945adf1c1ef9fb736d3986d363ba0b8d3b8f266ee39137146ace32c13f9704d4e8369ed36e9e758ff8b12d3b615eb7046fcd2be8b3dfc3c2e0d581aedf32fec29969\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","tags":["其他"]},{"title":"雷电模拟器&IDA动调.so文件","url":"/post/android.html","content":"前提：雷电模拟器开启root权限，模拟器设置中开启开发者模式&amp;&amp;USB调试\n\nadb push ../../../../android_x64_server \\data\\local\\tmpadb forward tcp:23946 tcp:23946adb shellsucd data/local/tmpchmod 777 android_x64_server./android_x64_server      #在进入adb shell 之前，可以先获得临时root身份（adb root），进入shell之后再获得超级管理员权限(su)\n\n虚拟机中运行apk，用ida打开.so文件：\n\n1.IDA打开so文件，定位到待分析函数并下断点：【New】【Export或Function window搜索函数双击定位】\n\n2.附加程序，进入动态调试界面：【Debugger—&gt;Process options】【Hostname:127.0.0.1 Port:23946】然后【Debugger—&gt;Attach to Process】\n\n\n\n找到自己想要的进程，attach.\n","tags":["安卓逆向"]},{"title":"记第一次Hook（Frida）和Apktool修改安卓程序","url":"/post/fd83d09f.html","content":"1.apltool基础操作：安卓apk反编译、修改、重新打包、签名全过程 - cnkker.com - 博客园\n2.Frida靶场：Frida练习靶场(上篇) - FreeBuf网络安全行业门户\n需要注意的是，在使用apktool时，文件路径不能有空格\nHook使用的是Frida靶场的第一个题：\n\n将输入与随机数做比较，匹配上就能得到flag，虽然说在CTF比赛中我们通常采用直接分析加密过程来解密，但是如果能熟练使用Hook，应该会更快一些。1.我选择Hook get_random函数，可以Hook生成数，也可以覆盖为自定义数选中函数，右键可以直接复制为Frida片段：\nlet MainActivity = Java.use(&quot;com.ad2001.frida0x1.MainActivity&quot;);MainActivity[&quot;get_random&quot;].implementation = function () &#123;    console.log(`MainActivity.get_random is called`);    let result = this[&quot;get_random&quot;]();    console.log(`MainActivity.get_random result=$&#123;result&#125;`);    return result;&#125;;\n套上:Java.perform(function(){    frida片段});在命令行使用frida -U -f 包名 -l test.js 就可以Hook上。\napktool篡改：已经下好了apktool并写入了环境变量\n反编译指令：\napktool d xxx.apk -o output_dir\n编译指令：\napktool b output_dir -o test.apk\n签名：生成keystore文件(java环境自带keytool)：\nkeytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore\n签名apk：\njarsigner -verbose -keystore demo.keystore test.apk demo.keystore\n\n篡改smali：源文件：\n\n可以修改返回值：修改返回值为0x1,即只要输入6就一定正确。\n","tags":["安卓逆向"]}]